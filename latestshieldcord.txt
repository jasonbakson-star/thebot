require('dotenv').config();
const { Client, GatewayIntentBits, Collection, PermissionFlagsBits, ChannelType, EmbedBuilder, ActivityType, AuditLogEvent, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js');
const fs = require('fs').promises;
const path = require('path');
const nodemailer = require('nodemailer');
const cron = require('node-cron');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildBans,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildModeration,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildInvites,
    GatewayIntentBits.GuildWebhooks,
    GatewayIntentBits.DirectMessages
  ]
});

client.commands = new Collection();
client.config = new Map();
client.warnings = new Map();
client.modCases = new Map();
client.tempBans = new Map();
client.muteRoles = new Map();
client.appeals = new Map();
client.blacklistedServers = new Set();
client.blacklistedUsers = new Set();
client.afkUsers = new Map();
client.quarantines = new Map();
client.userWhitelists = new Map();
client.serverPrefixes = new Map();
client.verificationRoles = new Map();
client.verificationCodes = new Map();
client.userEmails = new Map();
client.reactionRoles = new Map();
client.autoroleSettings = new Map();
client.quarantineRoles = new Map();
client.linkWhitelists = new Map();
client.proles = new Map(); // ‚≠ê NEW: Permission roles system

const antiNukeCache = new Map();
const raidDetection = new Map();
const messageCache = new Map();
const devLogs = [];
let maintenanceMode = false;
let caseCounter = new Map();

const DATA_DIR = path.join(__dirname, 'data');
const MOD_CASES_FILE = path.join(DATA_DIR, 'modCases.json');
const WARNINGS_FILE = path.join(DATA_DIR, 'warnings.json');
const CASE_COUNTER_FILE = path.join(DATA_DIR, 'caseCounter.json');
const TEMP_BANS_FILE = path.join(DATA_DIR, 'tempBans.json');
const APPEALS_FILE = path.join(DATA_DIR, 'appeals.json');
const BLACKLIST_FILE = path.join(DATA_DIR, 'blacklist.json');
const QUARANTINE_FILE = path.join(DATA_DIR, 'quarantines.json');
const USER_WHITELIST_FILE = path.join(DATA_DIR, 'userWhitelist.json');
const SERVER_PREFIXES_FILE = path.join(DATA_DIR, 'serverPrefixes.json');
const VERIFICATION_ROLES_FILE = path.join(DATA_DIR, 'verificationRoles.json');
const USER_EMAILS_FILE = path.join(DATA_DIR, 'userEmails.json');
const REACTION_ROLES_FILE = path.join(DATA_DIR, 'reactionRoles.json');
const AUTOROLE_SETTINGS_FILE = path.join(DATA_DIR, 'autoroleSettings.json');
const QUARANTINE_ROLES_FILE = path.join(DATA_DIR, 'quarantineRoles.json');
const LINK_WHITELIST_FILE = path.join(DATA_DIR, 'linkWhitelist.json');
const PROLES_FILE = path.join(DATA_DIR, 'proles.json'); // ‚≠ê NEW

// ‚≠ê NEW: Developer-only commands list
const DEVELOPER_COMMANDS = [
  '!shutdown',
  '!devlogs',
  '!maintenance',
  '!blacklist',
  '!eval'
];

async function ensureDataDir() {
  try {
    await fs.mkdir(DATA_DIR, { recursive: true });
  } catch (error) {
    console.error('Failed to create data directory:', error);
  }
}

async function loadData() {
  try {
    await ensureDataDir();
    
    try {
      const modCasesData = await fs.readFile(MOD_CASES_FILE, 'utf-8');
      const parsedCases = JSON.parse(modCasesData);
      client.modCases = new Map(Object.entries(parsedCases).map(([k, v]) => [k, v]));
      console.log('‚úÖ Loaded mod cases from file');
    } catch (err) {
      console.log('üìù No existing mod cases file, starting fresh');
    }

    try {
      const warningsData = await fs.readFile(WARNINGS_FILE, 'utf-8');
      const parsedWarnings = JSON.parse(warningsData);
      client.warnings = new Map(Object.entries(parsedWarnings).map(([k, v]) => [k, v]));
      console.log('‚úÖ Loaded warnings from file');
    } catch (err) {
      console.log('üìù No existing warnings file, starting fresh');
    }

    try {
      const caseCounterData = await fs.readFile(CASE_COUNTER_FILE, 'utf-8');
      const parsedCounter = JSON.parse(caseCounterData);
      caseCounter = new Map(Object.entries(parsedCounter).map(([k, v]) => [k, Number(v)]));
      console.log('‚úÖ Loaded case counter from file');
    } catch (err) {
      console.log('üìù No existing case counter file, starting fresh');
    }

    try {
      const tempBansData = await fs.readFile(TEMP_BANS_FILE, 'utf-8');
      const parsedTempBans = JSON.parse(tempBansData);
      client.tempBans = new Map(Object.entries(parsedTempBans).map(([k, v]) => [k, v]));
      console.log('‚úÖ Loaded temp bans from file');
    } catch (err) {
      console.log('üìù No existing temp bans file, starting fresh');
    }

    try {
      const appealsData = await fs.readFile(APPEALS_FILE, 'utf-8');
      const parsedAppeals = JSON.parse(appealsData);
      client.appeals = new Map(Object.entries(parsedAppeals).map(([k, v]) => [k, v]));
      console.log('‚úÖ Loaded appeals from file');
    } catch (err) {
      console.log('üìù No existing appeals file, starting fresh');
    }

    try {
      const blacklistData = await fs.readFile(BLACKLIST_FILE, 'utf-8');
      const parsedBlacklist = JSON.parse(blacklistData);
      client.blacklistedServers = new Set(parsedBlacklist.servers || []);
      client.blacklistedUsers = new Set(parsedBlacklist.users || []);
      console.log('‚úÖ Loaded blacklists from file');
    } catch (err) {
      console.log('üìù No existing blacklist file, starting fresh');
    }

    try {
      const quarantineData = await fs.readFile(QUARANTINE_FILE, 'utf-8');
      const parsedQuarantines = JSON.parse(quarantineData);
      client.quarantines = new Map(Object.entries(parsedQuarantines).map(([k, v]) => [k, v]));
      console.log('‚úÖ Loaded quarantines from file');
    } catch (err) {
      console.log('üìù No existing quarantines file, starting fresh');
    }

    try {
      const userWhitelistData = await fs.readFile(USER_WHITELIST_FILE, 'utf-8');
      const parsedWhitelist = JSON.parse(userWhitelistData);
      client.userWhitelists = new Map(Object.entries(parsedWhitelist).map(([k, v]) => [k, new Set(v)]));
      console.log('‚úÖ Loaded user whitelists from file');
    } catch (err) {
      console.log('üìù No existing user whitelist file, starting fresh');
    }

    try {
      const serverPrefixesData = await fs.readFile(SERVER_PREFIXES_FILE, 'utf-8');
      const parsedPrefixes = JSON.parse(serverPrefixesData);
      client.serverPrefixes = new Map(Object.entries(parsedPrefixes));
      console.log('‚úÖ Loaded server prefixes from file');
    } catch (err) {
      console.log('üìù No existing server prefixes file, starting fresh');
    }

    try {
      const verificationRolesData = await fs.readFile(VERIFICATION_ROLES_FILE, 'utf-8');
      const parsedVerificationRoles = JSON.parse(verificationRolesData);
      client.verificationRoles = new Map(Object.entries(parsedVerificationRoles));
      console.log('‚úÖ Loaded verification roles from file');
    } catch (err) {
      console.log('üìù No existing verification roles file, starting fresh');
    }

    try {
      const reactionRolesData = await fs.readFile(REACTION_ROLES_FILE, 'utf-8');
      const parsedReactionRoles = JSON.parse(reactionRolesData);
      client.reactionRoles = new Map(Object.entries(parsedReactionRoles).map(([messageId, data]) => [
        messageId,
        {
          guildId: data.guildId,
          channelId: data.channelId,
          roles: new Map(data.roles)
        }
      ]));
      console.log('‚úÖ Loaded reaction roles from file');
    } catch (err) {
      console.log('üìù No existing reaction roles file, starting fresh');
    }

    try {
      const autoroleSettingsData = await fs.readFile(AUTOROLE_SETTINGS_FILE, 'utf-8');
      const parsedAutoroleSettings = JSON.parse(autoroleSettingsData);
      client.autoroleSettings = new Map(Object.entries(parsedAutoroleSettings));
      console.log('‚úÖ Loaded autorole settings from file');
    } catch (err) {
      console.log('üìù No existing autorole settings file, starting fresh');
    }

    try {
      const quarantineRolesData = await fs.readFile(QUARANTINE_ROLES_FILE, 'utf-8');
      const parsedQuarantineRoles = JSON.parse(quarantineRolesData);
      client.quarantineRoles = new Map(Object.entries(parsedQuarantineRoles));
      console.log('‚úÖ Loaded quarantine roles from file');
    } catch (err) {
      console.log('üìù No existing quarantine roles file, starting fresh');
    }

    try {
      const linkWhitelistData = await fs.readFile(LINK_WHITELIST_FILE, 'utf-8');
      const parsedLinkWhitelist = JSON.parse(linkWhitelistData);
      client.linkWhitelists = new Map(Object.entries(parsedLinkWhitelist).map(([k, v]) => [k, new Set(v)]));
      console.log('‚úÖ Loaded link whitelists from file');
    } catch (err) {
      console.log('üìù No existing link whitelist file, starting fresh');

    // ‚≠ê NEW: Load proles
    try {
      const prolesData = await fs.readFile(PROLES_FILE, 'utf-8');
      const parsedProles = JSON.parse(prolesData);
      client.proles = new Map(Object.entries(parsedProles).map(([guildId, data]) => [
        guildId,
        {
          prolesData: data.prolesData || {},
          userProles: data.userProles || {}
        }
      ]));
      console.log('‚úÖ Loaded proles from file');
    } catch (err) {
      console.log('üìù No existing proles file, starting fresh');
    }
    }

    try {
      const userEmailsData = await fs.readFile(USER_EMAILS_FILE, 'utf-8');
      const parsedUserEmails = JSON.parse(userEmailsData);
      client.userEmails = new Map(Object.entries(parsedUserEmails));
      console.log('‚úÖ Loaded user emails from file');
    } catch (err) {
      console.log('üìù No existing user emails file, starting fresh');
    }
  } catch (error) {
    console.error('Error loading data:', error);
  }
}

async function saveModCases() {
  try {
    const obj = Object.fromEntries(client.modCases);
    await fs.writeFile(MOD_CASES_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save mod cases:', error);
  }
}

async function saveWarnings() {
  try {
    const obj = Object.fromEntries(client.warnings);
    await fs.writeFile(WARNINGS_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save warnings:', error);
  }
}

async function saveCaseCounter() {
  try {
    const obj = Object.fromEntries(caseCounter);
    await fs.writeFile(CASE_COUNTER_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save case counter:', error);
  }
}

async function saveTempBans() {
  try {
    const obj = Object.fromEntries(client.tempBans);
    await fs.writeFile(TEMP_BANS_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save temp bans:', error);
  }
}

async function saveAppeals() {
  try {
    const obj = Object.fromEntries(client.appeals);
    await fs.writeFile(APPEALS_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save appeals:', error);
  }
}

async function saveBlacklist() {
  try {
    const obj = {
      servers: Array.from(client.blacklistedServers),
      users: Array.from(client.blacklistedUsers)
    };
    await fs.writeFile(BLACKLIST_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save blacklist:', error);
  }
}

async function saveQuarantines() {
  try {
    const obj = Object.fromEntries(client.quarantines);
    await fs.writeFile(QUARANTINE_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save quarantines:', error);
  }
}

async function saveUserWhitelists() {
  try {
    const obj = Object.fromEntries(
      Array.from(client.userWhitelists.entries()).map(([k, v]) => [k, Array.from(v)])
    );
    await fs.writeFile(USER_WHITELIST_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save user whitelists:', error);
  }
}

async function saveServerPrefixes() {
  try {
    const obj = Object.fromEntries(client.serverPrefixes);
    await fs.writeFile(SERVER_PREFIXES_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save server prefixes:', error);
  }
}

async function saveVerificationRoles() {
  try {
    const obj = Object.fromEntries(client.verificationRoles);
    await fs.writeFile(VERIFICATION_ROLES_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save verification roles:', error);
  }
}

async function saveReactionRoles() {
  try {
    const obj = {};
    for (const [messageId, data] of client.reactionRoles.entries()) {
      obj[messageId] = {
        guildId: data.guildId,
        channelId: data.channelId,
        roles: Array.from(data.roles.entries())
      };
    }
    await fs.writeFile(REACTION_ROLES_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save reaction roles:', error);
  }
}

async function saveAutoroleSettings() {
  try {
    const obj = Object.fromEntries(client.autoroleSettings);
    await fs.writeFile(AUTOROLE_SETTINGS_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save autorole settings:', error);
  }
}

async function saveQuarantineRoles() {
  try {
    const obj = Object.fromEntries(client.quarantineRoles);
    await fs.writeFile(QUARANTINE_ROLES_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save quarantine roles:', error);
  }
}

async function saveLinkWhitelists() {
  try {
    const obj = Object.fromEntries(
      Array.from(client.linkWhitelists.entries()).map(([k, v]) => [k, Array.from(v)])
    );
    await fs.writeFile(LINK_WHITELIST_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save link whitelists:', error);
async function saveUserEmails() {
  try {
    const obj = Object.fromEntries(client.userEmails);
    await fs.writeFile(USER_EMAILS_FILE, JSON.stringify(obj, null, 2));
    console.log(`‚úÖ Successfully saved ${Object.keys(obj).length} user emails to file`);
  } catch (error) {
    console.error('‚ùå CRITICAL: Failed to save user emails:', error);
    console.error('Email data that failed to save:', client.userEmails.size);
  }
}
}

async function saveUserEmails() {
  try {
    const obj = Object.fromEntries(client.userEmails);
    await fs.writeFile(USER_EMAILS_FILE, JSON.stringify(obj, null, 2));
  } catch (error) {
    console.error('Failed to save user emails:', error);
  }


// ‚≠ê NEW: Save proles
async function saveProles() {
  try {
    const obj = {};
    for (const [guildId, data] of client.proles.entries()) {
      obj[guildId] = {
        prolesData: data.prolesData,
        userProles: data.userProles
      };
    }
    await fs.writeFile(PROLES_FILE, JSON.stringify(obj, null, 2));
    console.log('‚úÖ Proles saved successfully');
  } catch (error) {
    console.error('‚ùå Failed to save proles:', error);
  }
}

// ‚≠ê NEW: Initialize prole data for guild
function getProleData(guildId) {
  if (!client.proles.has(guildId)) {
    client.proles.set(guildId, {
      prolesData: {},
      userProles: {}
    });
  }
  return client.proles.get(guildId);
}

// ‚≠ê NEW: Get user's lowest rank number (0 = server owner, 1+ = prole ranks)
function getUserRank(userId, guildId, guild) {
  if (userId === guild.ownerId) return 0;
  if (userId === process.env.BOT_OWNER_ID) return 0;

  const guildProles = client.proles.get(guildId);
  if (!guildProles || !guildProles.userProles[userId]) {
    return 999;
  }

  const userProleNames = guildProles.userProles[userId];
  let lowestRank = 999;

  for (const proleName of userProleNames) {
    const proleData = guildProles.prolesData[proleName];
    if (proleData && proleData.rank < lowestRank) {
      lowestRank = proleData.rank;
    }
  }

  return lowestRank;
}

// ‚≠ê NEW: Check if user has permission via proles
function checkProlePermission(userId, guildId, command) {
  const guildProles = client.proles.get(guildId);
  if (!guildProles || !guildProles.userProles[userId]) {
    return false;
  }

  const userProleNames = guildProles.userProles[userId];

  for (const proleName of userProleNames) {
    const proleData = guildProles.prolesData[proleName];
    if (!proleData) continue;

    if (proleData.commands.includes('all')) {
      if (!DEVELOPER_COMMANDS.includes(command)) {
        return true;
      }
    }

    if (proleData.commands.includes(command)) {
      return true;
    }
  }

  return false;
}

// ‚≠ê NEW: Enhanced permission check for commands with prole support
function hasCommandPermission(member, guildId, command, config, requiredPermission = null) {
  if (member.guild.ownerId === member.user.id) return true;
  if (isOwner(member.user.id)) return true;
  if (checkPermissions(member, config, requiredPermission)) return true;
  if (checkProlePermission(member.user.id, guildId, command)) return true;
  return false;
}

}

let emailTransporter = null;
try {
  if (process.env.EMAIL_HOST && process.env.EMAIL_USER && process.env.EMAIL_PASS) {
    emailTransporter = nodemailer.createTransport({
      host: process.env.EMAIL_HOST,
      port: parseInt(process.env.EMAIL_PORT) || 587,
      secure: false,
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS
      }
    });
    console.log('‚úÖ Email transporter configured');
  }
} catch (error) {
  console.log('üìß Email not configured:', error.message);
}

function getPrefix(guildId) {
  return client.serverPrefixes.get(guildId) || '!';
}

function getConfig(guildId) {
  if (!client.config.has(guildId)) {
    client.config.set(guildId, {
      antiNukeEnabled: true,
      antiRaidEnabled: true,
      whitelistedUsers: new Set(),
      whitelistedBots: new Set(),
      logChannel: null,
      modLogChannel: null,
      joinLeaveLogChannel: null,
      messageLogChannel: null,
      raidThreshold: 5,
      raidTimeWindow: 10000,
      accountAgeThreshold: 7,
      moderatorRoles: new Set(),
      botDetectionEnabled: true,
      autoModEnabled: false,
      badWords: new Set(),
      maxWarnings: 3,
      warnKickThreshold: 3,
      warnBanThreshold: 5,
      antiSpamEnabled: false,
      maxMentions: 5,
      antiInviteEnabled: false,
      antiLinkEnabled: false,
      muteRoleId: null,
      quarantineChannelId: null
    });
  }
  return client.config.get(guildId);
}

function getWarnings(guildId, userId) {
  const key = `${guildId}-${userId}`;
  if (!client.warnings.has(key)) {
    client.warnings.set(key, []);
  }
  return client.warnings.get(key);
}

async function addWarning(guildId, userId, warning) {
  const warnings = getWarnings(guildId, userId);
  warnings.push(warning);
  await saveWarnings();
  return warnings.length;
}

async function clearWarnings(guildId, userId) {
  const key = `${guildId}-${userId}`;
  client.warnings.set(key, []);
  await saveWarnings();
}

async function getCaseNumber(guildId) {
  if (!caseCounter.has(guildId)) {
    caseCounter.set(guildId, 0);
  }
  const current = caseCounter.get(guildId) + 1;
  caseCounter.set(guildId, current);
  await saveCaseCounter();
  return current;
}

async function addModCase(guildId, caseData) {
  if (!client.modCases.has(guildId)) {
    client.modCases.set(guildId, []);
  }
  const cases = client.modCases.get(guildId);
  cases.push(caseData);
  await saveModCases();
  return caseData.caseId;
}

function getModCases(guildId, userId = null) {
  const cases = client.modCases.get(guildId) || [];
  if (userId) {
    return cases.filter(c => c.userId === userId);
  }
  return cases;
}

async function updateModCase(guildId, caseId, updates) {
  const cases = client.modCases.get(guildId) || [];
  const caseIndex = cases.findIndex(c => c.caseId === caseId);
  if (caseIndex !== -1) {
    cases[caseIndex] = { ...cases[caseIndex], ...updates };
    await saveModCases();
    return true;
  }
  return false;
}

function isOwner(userId) {
  return userId === process.env.BOT_OWNER_ID;
}

// ‚≠ê NEW FUNCTION: Check if user is bot owner OR server owner
function isBotOwnerOrServerOwner(userId, guild) {
  return userId === process.env.BOT_OWNER_ID || userId === guild.ownerId;
}

// ‚≠ê NEW FUNCTION: Check if user should be protected from quarantine/punishment
function isProtectedUser(userId, guild) {
  // Bot owner and server owner are protected from anti-nuke actions
  return userId === process.env.BOT_OWNER_ID || userId === guild.ownerId;
}

function checkPermissions(member, config, requiredPermission = null) {
  // Bot owner has access to all commands in all servers
  if (isOwner(member.user.id)) return true;
  
  if (member.permissions.has(PermissionFlagsBits.Administrator)) return true;
  
  if (requiredPermission && member.permissions.has(requiredPermission)) return true;
  
  if (config.moderatorRoles.size > 0) {
    return member.roles.cache.some(role => config.moderatorRoles.has(role.id));
  }
  
  return false;
}

async function logAction(guild, embed, channelType = 'log') {
  const config = getConfig(guild.id);
  let channelId;
  
  if (channelType === 'mod') {
    channelId = config.modLogChannel || config.logChannel;
  } else if (channelType === 'join') {
    channelId = config.joinLeaveLogChannel || config.logChannel;
  } else if (channelType === 'message') {
    channelId = config.messageLogChannel || config.logChannel;
  } else {
    channelId = config.logChannel;
  }
  
  if (!channelId) return;
  
  const channel = guild.channels.cache.get(channelId);
  if (channel && channel.isTextBased()) {
    await channel.send({ embeds: [embed] }).catch(() => {});
  }
}

async function createAdminAlertChannel(guild, title, description) {
  try {
    const alertChannel = await guild.channels.create({
      name: 'üö®-security-alert',
      type: ChannelType.GuildText,
      permissionOverwrites: [
        {
          id: guild.id,
          deny: [PermissionFlagsBits.ViewChannel]
        }
      ]
    });

    const admins = guild.members.cache.filter(member => 
      member.permissions.has(PermissionFlagsBits.Administrator) && !member.user.bot
    );

    for (const [, member] of admins) {
      await alertChannel.permissionOverwrites.create(member.id, {
        ViewChannel: true,
        SendMessages: true,
        ReadMessageHistory: true
      }).catch(() => {});
    }

    const adminMentions = admins.map(member => `<@${member.id}>`).join(' ');

    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle(title)
      .setDescription(description)
      .setFooter({ text: 'Shield Security Alert System | Powered By BotLabs' })
      .setTimestamp();

    await alertChannel.send({
      content: `${adminMentions}\n\n**‚ö†Ô∏è CRITICAL SECURITY ALERT**`,
      embeds: [embed]
    });

    return alertChannel;
  } catch (error) {
    console.error('Failed to create admin alert channel:', error);
    return null;
  }
}

function parseDuration(str) {
  const units = {
    s: 1,
    m: 60,
    h: 3600,
    d: 86400,
    w: 604800
  };
  
  const match = str.match(/^(\d+)([smhdw])$/);
  if (!match) return null;
  
  const value = parseInt(match[1]);
  const unit = match[2];
  
  return value * units[unit];
}

function formatDuration(seconds) {
  const units = [
    { name: 'week', value: 604800 },
    { name: 'day', value: 86400 },
    { name: 'hour', value: 3600 },
    { name: 'minute', value: 60 },
    { name: 'second', value: 1 }
  ];
  
  for (const unit of units) {
    if (seconds >= unit.value) {
      const amount = Math.floor(seconds / unit.value);
      return `${amount} ${unit.name}${amount !== 1 ? 's' : ''}`;
    }
  }
  return 'instant';
}

async function getMuteRole(guild) {
  const config = getConfig(guild.id);
  
  if (config.muteRoleId) {
    const role = guild.roles.cache.get(config.muteRoleId);
    if (role) return role;
  }
  
  let muteRole = guild.roles.cache.find(r => r.name === 'Muted');
  
  if (!muteRole) {
    muteRole = await guild.roles.create({
      name: 'Muted',
      color: '#808080',
      permissions: [],
      reason: 'Auto-created mute role'
    });
    
    for (const channel of guild.channels.cache.values()) {
      await channel.permissionOverwrites.create(muteRole, {
        SendMessages: false,
        AddReactions: false,
        Speak: false
      }).catch(() => {});
    }
    
    config.muteRoleId = muteRole.id;
  }
  
  return muteRole;
}

async function checkTempBans() {
  const now = Date.now();
  const toUnban = [];
  
  for (const [key, data] of client.tempBans.entries()) {
    if (now >= data.unbanTime) {
      toUnban.push({ key, data });
    }
  }
  
  for (const { key, data } of toUnban) {
    try {
      const guild = client.guilds.cache.get(data.guildId);
      if (guild) {
        await guild.members.unban(data.userId, 'Temporary ban expired');
        
        const embed = new EmbedBuilder()
          .setColor('#00FF00')
          .setTitle('‚è∞ Temporary Ban Expired')
          .setDescription(`**User ID:** ${data.userId}\n**Duration:** ${formatDuration(data.duration)}`)
          .setTimestamp();
        
        await logAction(guild, embed, 'mod');
      }
      client.tempBans.delete(key);
    } catch (error) {
      console.error(`Failed to unban ${data.userId}:`, error);
    }
  }
  
  if (toUnban.length > 0) {
    await saveTempBans();
  }
}

async function getQuarantineChannel(guild) {
  const config = getConfig(guild.id);
  
  if (config.quarantineChannelId) {
    const channel = guild.channels.cache.get(config.quarantineChannelId);
    if (channel) return channel;
  }
  
  let quarantineChannel = guild.channels.cache.find(c => c.name === 'quarantine');
  
  if (!quarantineChannel) {
    quarantineChannel = await guild.channels.create({
      name: 'quarantine',
      type: ChannelType.GuildText,
      permissionOverwrites: [
        {
          id: guild.id,
          deny: [PermissionFlagsBits.ViewChannel]
        }
      ],
      reason: 'Auto-created quarantine channel'
    });
    
    config.quarantineChannelId = quarantineChannel.id;
  }
  
  return quarantineChannel;
}

async function quarantineUser(guild, member, reason, duration = null) {
  const config = getConfig(guild.id);
  const key = `${guild.id}-${member.id}`;
  
  const originalRoles = member.roles.cache
    .filter(role => role.id !== guild.id)
    .map(role => role.id);
  
  const quarantineRoleId = client.quarantineRoles.get(guild.id);
  if (quarantineRoleId) {
    const quarantineRole = guild.roles.cache.get(quarantineRoleId);
    if (quarantineRole) {
      await member.roles.set([quarantineRole], reason).catch(() => {});
    } else {
      await member.roles.set([], reason).catch(() => {});
    }
  } else {
    await member.roles.set([], reason).catch(() => {});
  }
  
  const quarantineChannel = await getQuarantineChannel(guild);
  await quarantineChannel.permissionOverwrites.create(member.id, {
    ViewChannel: true,
    SendMessages: true,
    ReadMessageHistory: true
  }).catch(() => {});
  
  const quarantineData = {
    guildId: guild.id,
    userId: member.id,
    reason: reason,
    moderator: 'Anti-Nuke System',
    timestamp: Date.now(),
    originalRoles: originalRoles,
    duration: duration,
    releaseTime: duration ? Date.now() + (duration * 1000) : null
  };
  
  client.quarantines.set(key, quarantineData);
  await saveQuarantines();
  
  return quarantineData;
}

async function unquarantineUser(guild, userId) {
  const key = `${guild.id}-${userId}`;
  const quarantineData = client.quarantines.get(key);
  
  if (!quarantineData) return false;
  
  const member = await guild.members.fetch(userId).catch(() => null);
  
  if (member) {
    const validRoles = quarantineData.originalRoles.filter(roleId => guild.roles.cache.has(roleId));
    await member.roles.set(validRoles, 'Quarantine released').catch(() => {});
    
    const quarantineChannel = await getQuarantineChannel(guild);
    await quarantineChannel.permissionOverwrites.delete(userId).catch(() => {});
  }
  
  client.quarantines.delete(key);
  await saveQuarantines();
  
  return true;
}

async function checkTempQuarantines() {
  const now = Date.now();
  const toRelease = [];
  
  for (const [key, data] of client.quarantines.entries()) {
    if (data.releaseTime && now >= data.releaseTime) {
      toRelease.push({ key, data });
    }
  }
  
  for (const { key, data } of toRelease) {
    try {
      const guild = client.guilds.cache.get(data.guildId);
      if (guild) {
        await unquarantineUser(guild, data.userId);
        
        const embed = new EmbedBuilder()
          .setColor('#00FF00')
          .setTitle('‚è∞ Temporary Quarantine Expired')
          .setDescription(`**User ID:** ${data.userId}\n**Duration:** ${formatDuration(data.duration)}\n**Reason:** ${data.reason}`)
          .setTimestamp();
        
        await logAction(guild, embed, 'mod');
      }
    } catch (error) {
      console.error(`Failed to release ${data.userId} from quarantine:`, error);
    }
  }
}

client.on('ready', async () => {
  console.log(`‚úÖ Shield Security is online as ${client.user.tag}`);
  console.log(`üìä Serving ${client.guilds.cache.size} servers`);
  
  // ‚≠ê Log bot owner ID on startup
  if (process.env.BOT_OWNER_ID) {
    console.log(`üëë Bot Owner ID: ${process.env.BOT_OWNER_ID}`);
  } else {
    console.log(`‚ö†Ô∏è WARNING: BOT_OWNER_ID not set in .env file!`);
  }
  
  const totalMembers = client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0);
  client.user.setActivity(`Shielding ${client.guilds.cache.size} servers And ${totalMembers} members`, { type: ActivityType.Watching });
  
  setInterval(checkTempBans, 60000);
  setInterval(checkTempQuarantines, 60000);
});

client.on('guildCreate', (guild) => {
  console.log(`üì• Joined new server: ${guild.name} (${guild.id})`);
  console.log(`üìä Now serving ${client.guilds.cache.size} servers`);
  const totalMembers = client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0);
  client.user.setActivity(`Shielding ${client.guilds.cache.size} servers And ${totalMembers} members`, { type: ActivityType.Watching });
});

client.on('guildDelete', (guild) => {
  console.log(`üì§ Left server: ${guild.name} (${guild.id})`);
  console.log(`üìä Now serving ${client.guilds.cache.size} servers`);
  const totalMembers = client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0);
  client.user.setActivity(`Shielding ${client.guilds.cache.size} servers And ${totalMembers} members`, { type: ActivityType.Watching });
});

client.on('messageCreate', async (message) => {
  if (message.author.bot) return;
  
  
  // ===== DM-BASED VERIFICATION HANDLER =====
  if (!message.guild) {
    // Handle DM messages for email verification
    if (client.verificationCodes.has(message.author.id)) {
      const verificationData = client.verificationCodes.get(message.author.id);
      
      // Waiting for email input
      if (verificationData.waitingForEmail) {
        const userEmail = message.content.trim();
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        
        if (!emailRegex.test(userEmail)) {
          return message.reply('‚ùå Invalid email format. Please provide a valid email address.');
        }

        // Generate and send verification code
        const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();
        
        try {
          await emailTransporter.sendMail({
            from: process.env.EMAIL_USER,
            to: userEmail,
            subject: 'Discord Server Verification Code',
            html: `
              <h2>Discord Verification</h2>
              <p>Your verification code is: <strong>${verificationCode}</strong></p>
              <p>Enter this code in your DMs with the bot to complete verification.</p>
              <p><em>This code expires in 10 minutes.</em></p>
            `
          });

          // Update verification data
          verificationData.code = verificationCode;
          verificationData.email = userEmail;
          verificationData.waitingForEmail = false;
          verificationData.waitingForCode = true;
          verificationData.timestamp = Date.now();
          
          client.verificationCodes.set(message.author.id, verificationData);

          return message.reply(`‚úÖ **Verification code sent to:** \`${userEmail}\`\n\nPlease check your email and reply with the 6-digit code.\n\n*Code expires in 10 minutes.*`);
        } catch (error) {
          console.error('Email send error:', error);
          return message.reply('‚ùå Failed to send verification email. Please make sure the email address is correct and try again.');
        }
      }
      
      // Waiting for code input
      if (verificationData.waitingForCode) {
        const enteredCode = message.content.trim();
        
        if (!/^\d{6}$/.test(enteredCode)) {
          return message.reply('‚ùå Please enter a valid 6-digit code.');
        }

        if (enteredCode !== verificationData.code) {
          return message.reply('‚ùå Incorrect verification code. Please try again or start over with `!verify`.');
        }

        if (Date.now() - verificationData.timestamp > 600000) {
          client.verificationCodes.delete(message.author.id);
          return message.reply('‚ùå Verification code expired. Please start over with `!verify` in the server.');
        }

        // Verification successful - assign role
        try {
          const guild = client.guilds.cache.get(verificationData.guildId);
          const member = await guild.members.fetch(message.author.id);
          const role = guild.roles.cache.get(verificationData.roleId);

          if (!role) {
            client.verificationCodes.delete(message.author.id);
            return message.reply('‚ùå Verification role no longer exists. Please contact an administrator.');
          }

          await member.roles.add(role);
          client.verificationCodes.delete(message.author.id);

          // Save user email
          client.userEmails.set(message.author.id, {
            email: verificationData.email,
            guildId: guild.id,
            verifiedAt: new Date().toISOString(),
            discordTag: message.author.tag
          });
          await saveUserEmails();

          await message.reply(`‚úÖ **Verification successful!**\n\nYou have been assigned the **${role.name}** role in **${guild.name}**.\n\nThis email has been securely stored.`);

          // Log the verification
          const logEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ User Verified')
            .setDescription(`**User:** ${message.author.tag} (${message.author.id})\n**Email:** \`${verificationData.email}\`\n**Role Assigned:** ${role}`)
            .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
            .setTimestamp();
          
          await logAction(guild, logEmbed, 'mod');
        } catch (error) {
          console.error('Verification error:', error);
          return message.reply('‚ùå An error occurred during verification. Please try again later.');
        }
      }
    }
    return; // Exit early for all DM messages
  }
  // ===== END DM HANDLER =====


  if (client.blacklistedServers.has(message.guild.id)) {
    return;
  }

  if (client.blacklistedUsers.has(message.author.id)) {
    return;
  }

  if (client.afkUsers.has(message.author.id)) {
    client.afkUsers.delete(message.author.id);
    message.reply('Welcome back! Your AFK status has been removed.').then(msg => {
      setTimeout(() => msg.delete().catch(() => {}), 5000);
    });
  }

  const mentioned = message.mentions.users.first();
  if (mentioned && client.afkUsers.has(mentioned.id)) {
    const afkData = client.afkUsers.get(mentioned.id);
    message.reply(`${mentioned.tag} is currently AFK: ${afkData.reason}`).then(msg => {
      setTimeout(() => msg.delete().catch(() => {}), 5000);
    });
  }

  const config = getConfig(message.guild.id);

  if (!messageCache.has(message.guild.id)) {
    messageCache.set(message.guild.id, []);
  }
  const cache = messageCache.get(message.guild.id);
  cache.push({ id: message.id, content: message.content, author: message.author.tag, channel: message.channel.id, timestamp: Date.now() });
  if (cache.length > 100) cache.shift();

  if (config.autoModEnabled && config.badWords.size > 0) {
    const content = message.content.toLowerCase();
    for (const word of config.badWords) {
      if (content.includes(word.toLowerCase())) {
        await message.delete().catch(() => {});
        const warning = {
          reason: `Auto-Mod: Used prohibited word "${word}"`,
          moderator: 'Auto-Mod',
          timestamp: Date.now()
        };
        const warnCount = await addWarning(message.guild.id, message.author.id, warning);
        
        let punishmentAction = '';
        let dmMessage = '';
        let punishmentApplied = false;
        
        if (warnCount === 1) {
          if (message.member.moderatable) {
            await message.member.timeout(10 * 60 * 1000, `Auto-Mod: Warning 1 - 10 minute timeout for using prohibited word`);
            punishmentAction = 'üîá **10 minute timeout**';
            punishmentApplied = true;
          } else {
            punishmentAction = 'üîá **10 minute timeout** (failed - insufficient permissions)';
          }
          dmMessage = `You have received **Warning 1/5** in **${message.guild.name}** for using a prohibited word.\n\n**Word:** ${word}\n**Punishment:** 10 minute timeout${!punishmentApplied ? ' (could not be applied)' : ''}\n**Next:** 2nd warning = 1 hour timeout`;
        } else if (warnCount === 2) {
          if (message.member.moderatable) {
            await message.member.timeout(60 * 60 * 1000, `Auto-Mod: Warning 2 - 1 hour timeout for using prohibited word`);
            punishmentAction = 'üîá **1 hour timeout**';
            punishmentApplied = true;
          } else {
            punishmentAction = 'üîá **1 hour timeout** (failed - insufficient permissions)';
          }
          dmMessage = `You have received **Warning 2/5** in **${message.guild.name}** for using a prohibited word.\n\n**Word:** ${word}\n**Punishment:** 1 hour timeout${!punishmentApplied ? ' (could not be applied)' : ''}\n**Next:** 3rd warning = 1 day timeout`;
        } else if (warnCount === 3) {
          if (message.member.moderatable) {
            await message.member.timeout(24 * 60 * 60 * 1000, `Auto-Mod: Warning 3 - 1 day timeout for using prohibited word`);
            punishmentAction = 'üîá **1 day timeout**';
            punishmentApplied = true;
          } else {
            punishmentAction = 'üîá **1 day timeout** (failed - insufficient permissions)';
          }
          dmMessage = `You have received **Warning 3/5** in **${message.guild.name}** for using a prohibited word.\n\n**Word:** ${word}\n**Punishment:** 1 day timeout${!punishmentApplied ? ' (could not be applied)' : ''}\n**Next:** 4th warning = kick`;
        } else if (warnCount === 4) {
          if (message.member.kickable) {
            await message.member.kick(`Auto-Mod: Warning 4 - Kicked for using prohibited word`);
            punishmentAction = 'üë¢ **Kicked from server**';
            punishmentApplied = true;
          } else {
            punishmentAction = 'üë¢ **Kick** (failed - insufficient permissions)';
          }
          dmMessage = `You have received **Warning 4/5** in **${message.guild.name}** for using a prohibited word.\n\n**Word:** ${word}\n**Punishment:** Kick from server${!punishmentApplied ? ' (could not be applied)' : ''}\n**Next:** 5th warning = permanent ban`;
        } else if (warnCount >= 5) {
          if (message.member.bannable) {
            await message.member.ban({ reason: `Auto-Mod: Warning 5 - Permanent ban for using prohibited word` });
            punishmentAction = 'üî® **Permanently banned**';
            punishmentApplied = true;
          } else {
            punishmentAction = 'üî® **Permanent ban** (failed - insufficient permissions)';
          }
          dmMessage = `You have received **Warning 5/5** in **${message.guild.name}** for using a prohibited word.\n\n**Word:** ${word}\n**Punishment:** Permanent ban${!punishmentApplied ? ' (could not be applied)' : ''}\n\nThis is your final punishment.`;
        }
        
        try {
          if (dmMessage) {
            const dmEmbed = new EmbedBuilder()
              .setColor('#FF0000')
              .setTitle('‚ö†Ô∏è Auto-Moderation Action')
              .setDescription(dmMessage)
              .setFooter({ text: message.guild.name })
              .setTimestamp();
            
            await message.author.send({ embeds: [dmEmbed] });
          }
        } catch (e) {
          console.log(`Could not DM ${message.author.tag}`);
        }
        
        await message.channel.send(`‚ö†Ô∏è ${message.author}, that word is not allowed! **Warning ${warnCount}/5** - ${punishmentAction}`).then(msg => {
          setTimeout(() => msg.delete().catch(() => {}), 8000);
        });
        
        const logEmbed = new EmbedBuilder()
          .setColor('#FFA500')
          .setTitle('ü§ñ Auto-Mod: Bad Word Detected')
          .setDescription(`**User:** ${message.author.tag}\n**Word:** ${word}\n**Warnings:** ${warnCount}/5\n**Action:** ${punishmentAction || 'Warning only'}`)
          .setTimestamp();
        
        await logAction(message.guild, logEmbed, 'mod');
        
        return;
      }
    }
  }

  if (config.antiInviteEnabled && !checkPermissions(message.member, config)) {
    const inviteRegex = /(discord\.gg|discord\.com\/invite|discordapp\.com\/invite)\/[a-zA-Z0-9]+/gi;
    if (inviteRegex.test(message.content)) {
      await message.delete().catch(() => {});
      await message.channel.send(`‚ùå ${message.author}, invite links are not allowed!`).then(msg => {
        setTimeout(() => msg.delete().catch(() => {}), 5000);
      });
      return;
    }
  }

  if (config.antiLinkEnabled && !checkPermissions(message.member, config)) {
    const urlRegex = /(https?:\/\/[^\s]+)/gi;
    const urls = message.content.match(urlRegex);
    
    if (urls && urls.length > 0) {
      const whitelist = client.linkWhitelists.get(message.guild.id) || new Set();
      
      for (const url of urls) {
        try {
          const urlObj = new URL(url);
          const domain = urlObj.hostname.replace(/^www\./, '');
          
          if (!whitelist.has(domain)) {
            await message.delete().catch(() => {});
            await message.channel.send(`‚ùå ${message.author}, links to **${domain}** are not allowed! Only whitelisted domains can be posted.`).then(msg => {
              setTimeout(() => msg.delete().catch(() => {}), 8000);
            });
            
            const logEmbed = new EmbedBuilder()
              .setColor('#FFA500')
              .setTitle('üîó Anti-Link: Blocked Link')
              .setDescription(`**User:** ${message.author.tag}\n**Domain:** ${domain}\n**URL:** ${url}\n**Action:** Message deleted`)
              .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
              .setTimestamp();
            
            await logAction(message.guild, logEmbed, 'mod');
            return;
          }
        } catch (e) {
          console.error('Error parsing URL:', e);
        }
      }
    }
  }

  if (config.antiSpamEnabled) {
    const mentions = message.mentions.users.size;
    if (mentions >= config.maxMentions) {
      await message.delete().catch(() => {});
      if (message.member.kickable) {
        await message.member.kick('Auto-Mod: Mass mention spam').catch(() => {});
        const logEmbed = new EmbedBuilder()
          .setColor('#FF0000')
          .setTitle('üö® Auto-Mod: Mass Mention Detected')
          .setDescription(`**User:** ${message.author.tag}\n**Mentions:** ${mentions}\n**Action:** Kicked`)
          .setTimestamp();
        await logAction(message.guild, logEmbed, 'mod');
      }
      return;
    }
  }

  const prefix = getPrefix(message.guild.id);
  if (!message.content.startsWith(prefix)) return;

  const args = message.content.slice(prefix.length).trim().split(/ +/);
  const commandName = args.shift().toLowerCase();


  // ‚≠ê‚≠ê‚≠ê PROLE COMMANDS ‚≠ê‚≠ê‚≠ê

  if (commandName === 'create_prole') {
    if (message.guild.ownerId !== message.author.id && !isOwner(message.author.id) && !checkProlePermission(message.author.id, message.guild.id, '!create_prole')) {
      return message.reply('‚ùå You need to be the server owner or have `!create_prole` permission.');
    }
    if (args.length < 3) {
      return message.reply('‚ùå Usage: `!create_prole <name> <rank> <command1> <command2> ...`\n\nExample: `!create_prole co-owner 1 !antinuke !ban !kick`\n\n**Note:** Use `all` to grant all non-developer commands.');
    }
    const proleName = args[0].toLowerCase();
    const rank = parseInt(args[1]);
    const commands = args.slice(2);
    if (isNaN(rank) || rank < 1 || rank > 999) {
      return message.reply('‚ùå Rank must be between 1 and 999.');
    }
    if (message.guild.ownerId !== message.author.id && !isOwner(message.author.id)) {
      const userRank = getUserRank(message.author.id, message.guild.id, message.guild);
      if (rank <= userRank) {
        return message.reply(`‚ùå You can only create proles with rank higher than yours (your rank: ${userRank}).`);
      }
    }
    const guildProles = getProleData(message.guild.id);
    if (guildProles.prolesData[proleName]) {
      return message.reply(`‚ùå Prole **${proleName}** already exists!`);
    }
    guildProles.prolesData[proleName] = {
      rank: rank,
      commands: commands,
      createdBy: message.author.id,
      createdAt: Date.now()
    };
    await saveProles();
    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ Permission Role Created')
      .setDescription(`**Name:** ${proleName}\n**Rank:** ${rank}\n**Commands:** ${commands.includes('all') ? '`all` (All non-dev commands)' : commands.join(', ')}\n**Created by:** ${message.author.tag}`)
      .setFooter({ text: 'Shield Security v1.5.0 | Powered By BotLabs' })
      .setTimestamp();
    await message.reply({ embeds: [embed] });
    const logEmbed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('üé≠ Prole Created')
      .setDescription(`**Prole:** ${proleName}\n**Rank:** ${rank}\n**Creator:** ${message.author.tag}`)
      .setTimestamp();
    await logAction(message.guild, logEmbed, 'mod');
  }

  if (commandName === 'delete_prole') {
    if (args.length < 1) return message.reply('‚ùå Usage: `!delete_prole <name>`');
    const proleName = args[0].toLowerCase();
    const guildProles = getProleData(message.guild.id);
    if (!guildProles.prolesData[proleName]) {
      return message.reply(`‚ùå Prole **${proleName}** does not exist!`);
    }
    const proleData = guildProles.prolesData[proleName];
    const isCreator = proleData.createdBy === message.author.id;
    const isServerOwner = message.guild.ownerId === message.author.id;
    const isBotOwner = isOwner(message.author.id);
    const hasPermission = checkProlePermission(message.author.id, message.guild.id, '!delete_prole');
    if (!isCreator && !isServerOwner && !isBotOwner && !hasPermission) {
      return message.reply('‚ùå You need to be creator, server owner, or have `!delete_prole` permission.');
    }
    if (!isCreator && !isServerOwner && !isBotOwner) {
      const userRank = getUserRank(message.author.id, message.guild.id, message.guild);
      if (proleData.rank <= userRank) {
        return message.reply(`‚ùå You can only delete proles with rank higher than yours.`);
      }
    }
    for (const userId in guildProles.userProles) {
      guildProles.userProles[userId] = guildProles.userProles[userId].filter(p => p !== proleName);
      if (guildProles.userProles[userId].length === 0) delete guildProles.userProles[userId];
    }
    delete guildProles.prolesData[proleName];
    await saveProles();
    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('üóëÔ∏è Permission Role Deleted')
      .setDescription(`**Name:** ${proleName}\n**Rank:** ${proleData.rank}\n**Deleted by:** ${message.author.tag}`)
      .setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'give_prole') {
    if (args.length < 2) return message.reply('‚ùå Usage: `!give_prole <@user> <prole_name>`');
    const targetUser = message.mentions.members.first();
    if (!targetUser) return message.reply('‚ùå Please mention a valid user.');
    if (targetUser.id === message.author.id) return message.reply('‚ùå You cannot give proles to yourself!');
    const proleName = args[1].toLowerCase();
    const guildProles = getProleData(message.guild.id);
    if (!guildProles.prolesData[proleName]) {
      return message.reply(`‚ùå Prole **${proleName}** does not exist!`);
    }
    const proleData = guildProles.prolesData[proleName];
    const isServerOwner = message.guild.ownerId === message.author.id;
    const isBotOwner = isOwner(message.author.id);
    const hasPermission = checkProlePermission(message.author.id, message.guild.id, '!give_prole');
    if (!isServerOwner && !isBotOwner && !hasPermission) {
      return message.reply('‚ùå You need server owner or `!give_prole` permission.');
    }
    if (!isServerOwner && !isBotOwner) {
      const userRank = getUserRank(message.author.id, message.guild.id, message.guild);
      if (proleData.rank <= userRank) {
        return message.reply(`‚ùå You can only give proles with rank higher than yours.`);
      }
    }
    if (!guildProles.userProles[targetUser.id]) guildProles.userProles[targetUser.id] = [];
    if (guildProles.userProles[targetUser.id].includes(proleName)) {
      return message.reply(`‚ùå ${targetUser.user.tag} already has **${proleName}**!`);
    }
    guildProles.userProles[targetUser.id].push(proleName);
    await saveProles();
    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ Permission Role Assigned')
      .setDescription(`**User:** ${targetUser.user.tag}\n**Prole:** ${proleName}\n**Rank:** ${proleData.rank}\n**By:** ${message.author.tag}`)
      .setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'remove_prole') {
    if (args.length < 2) return message.reply('‚ùå Usage: `!remove_prole <@user> <prole_name>`');
    const targetUser = message.mentions.members.first();
    if (!targetUser) return message.reply('‚ùå Please mention a valid user.');
    const proleName = args[1].toLowerCase();
    const guildProles = getProleData(message.guild.id);
    if (!guildProles.prolesData[proleName]) {
      return message.reply(`‚ùå Prole **${proleName}** does not exist!`);
    }
    const proleData = guildProles.prolesData[proleName];
    const isServerOwner = message.guild.ownerId === message.author.id;
    const isBotOwner = isOwner(message.author.id);
    const hasPermission = checkProlePermission(message.author.id, message.guild.id, '!remove_prole');
    if (!isServerOwner && !isBotOwner && !hasPermission) {
      return message.reply('‚ùå You need server owner or `!remove_prole` permission.');
    }
    if (!isServerOwner && !isBotOwner) {
      const userRank = getUserRank(message.author.id, message.guild.id, message.guild);
      if (proleData.rank <= userRank) {
        return message.reply(`‚ùå You can only remove proles with rank higher than yours.`);
      }
    }
    if (!guildProles.userProles[targetUser.id] || !guildProles.userProles[targetUser.id].includes(proleName)) {
      return message.reply(`‚ùå ${targetUser.user.tag} does not have **${proleName}**!`);
    }
    guildProles.userProles[targetUser.id] = guildProles.userProles[targetUser.id].filter(p => p !== proleName);
    if (guildProles.userProles[targetUser.id].length === 0) delete guildProles.userProles[targetUser.id];
    await saveProles();
    const embed = new EmbedBuilder()
      .setColor('#FF6600')
      .setTitle('üóëÔ∏è Permission Role Removed')
      .setDescription(`**User:** ${targetUser.user.tag}\n**Prole:** ${proleName}\n**By:** ${message.author.tag}`)
      .setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'list_proles') {
    const guildProles = getProleData(message.guild.id);
    const proles = Object.entries(guildProles.prolesData);
    if (proles.length === 0) {
      return message.reply('‚ùå No permission roles created yet.');
    }
    proles.sort((a, b) => a[1].rank - b[1].rank);
    const embed = new EmbedBuilder()
      .setColor('#0099FF')
      .setTitle(`üé≠ Permission Roles in ${message.guild.name}`)
      .setDescription(proles.map(([name, data]) => {
        const cmdDisplay = data.commands.includes('all') ? '`all` (All non-dev)' : 
          data.commands.length > 5 ? `${data.commands.slice(0,5).join(', ')} +${data.commands.length-5} more` : 
          data.commands.join(', ');
        return `**${name}** - Rank ${data.rank}\n‚îî ${cmdDisplay}`;
      }).join('\n\n'))
      .setFooter({ text: `Total: ${proles.length} proles` })
      .setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'user_proles') {
    const targetUser = message.mentions.members.first() || message.member;
    const guildProles = getProleData(message.guild.id);
    const userProles = guildProles.userProles[targetUser.id] || [];
    if (userProles.length === 0) {
      return message.reply(`${targetUser.id === message.author.id ? 'You have' : `${targetUser.user.tag} has`} no permission roles.`);
    }
    const proleDetails = userProles.map(name => {
      const data = guildProles.prolesData[name];
      return `**${name}** - Rank ${data.rank}`;
    }).join('\n');
    const userRank = getUserRank(targetUser.id, message.guild.id, message.guild);
    const embed = new EmbedBuilder()
      .setColor('#0099FF')
      .setTitle(`üé≠ ${targetUser.user.tag}'s Permission Roles`)
      .setDescription(`**Effective Rank:** ${userRank === 0 ? '0 (Server Owner)' : userRank}\n\n${proleDetails}`)
      .setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'prole_info') {
    if (args.length < 1) return message.reply('‚ùå Usage: `!prole_info <prole_name>`');
    const proleName = args[0].toLowerCase();
    const guildProles = getProleData(message.guild.id);
    if (!guildProles.prolesData[proleName]) {
      return message.reply(`‚ùå Prole **${proleName}** does not exist!`);
    }
    const data = guildProles.prolesData[proleName];
    const creator = await client.users.fetch(data.createdBy).catch(() => null);
    const userCount = Object.values(guildProles.userProles).filter(proles => proles.includes(proleName)).length;
    const cmdDisplay = data.commands.includes('all') ? '`all` ‚úÖ (All non-dev commands)' : data.commands.join(', ');
    const embed = new EmbedBuilder()
      .setColor('#0099FF')
      .setTitle(`üé≠ Prole Info: ${proleName}`)
      .addFields(
        { name: 'üìä Rank', value: data.rank.toString(), inline: true },
        { name: 'üë• Users', value: userCount.toString(), inline: true },
        { name: 'üë§ Created By', value: creator ? creator.tag : 'Unknown', inline: true },
        { name: 'üìÖ Created', value: `<t:${Math.floor(data.createdAt/1000)}:R>`, inline: true },
        { name: '‚ö° Commands', value: cmdDisplay, inline: false }
      )
      .setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  // ‚≠ê‚≠ê‚≠ê END PROLE COMMANDS ‚≠ê‚≠ê‚≠ê

  if (maintenanceMode && !isOwner(message.author.id)) {
    return message.reply('‚ö†Ô∏è **Shield Security is currently in maintenance mode.** The bot is temporarily disabled. Please try again later.');
  }

  if (commandName === 'ping') {
    const sent = await message.reply('üèì Pinging...');
    const latency = sent.createdTimestamp - message.createdTimestamp;
    
    const embed = new EmbedBuilder()
      .setColor('#5865F2')
      .setTitle('üèì Pong!')
      .setDescription('Check the bot\'s response time and connection status.')
      .addFields(
        { name: 'üì° Bot Latency', value: `\`${latency}ms\``, inline: true },
        { name: 'üíì API Latency', value: `\`${Math.round(client.ws.ping)}ms\``, inline: true },
        { name: '‚è±Ô∏è Uptime', value: `\`${Math.floor(client.uptime / 1000 / 60)} min\``, inline: true }
      )
      .setFooter({ text: 'Shield Security System | Powered By BotLabs' })
      .setTimestamp();
    
    await sent.edit({ content: '', embeds: [embed] });
  }

  if (commandName === 'help') {
    const category = args[0]?.toLowerCase();

    if (!category) {
      const mainEmbed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üõ°Ô∏è Shield Security')
        .setDescription('**Advanced Discord Protection & Moderation System**\n\nSelect a category below to view available commands.')
        .addFields(
          { name: 'üîí Security', value: 'Anti-nuke, anti-raid protection\n`!help security`', inline: true },
          { name: '‚öîÔ∏è Moderation', value: 'Ban, kick, mute, timeout\n`!help moderation`', inline: true },
          { name: '‚ö†Ô∏è Warnings', value: 'Warning & case system\n`!help warnings`', inline: true },
          { name: 'üõ°Ô∏è Channels', value: 'Lock, unlock, slowmode\n`!help channels`', inline: true },
          { name: 'ü§ñ AutoMod', value: 'Automated moderation\n`!help automod`', inline: true },
          { name: '‚úÖ Verification', value: 'Email verification system\n`!help verification`', inline: true },
          { name: 'üé≠ Roles', value: 'Role management\n`!help roles`', inline: true },
          { name: '‚öôÔ∏è Config', value: 'Server configuration\n`!help config`', inline: true },
          { name: 'üìä Utility', value: 'Info & utility commands\n`!help utility`', inline: true },
          { name: 'üíæ Server', value: 'Backup & restore\n`!help server`', inline: true },
          { name: 'üîß Developer', value: 'Developer commands\n`!help developer`', inline: true }
        )
        .setFooter({ text: 'Shield Security v1.4.5 | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [mainEmbed] });
    }

    let embed;
    
    if (category === 'security') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üîí Security Commands')
        .setDescription('Protect your server from raids, nukes, and malicious activity.')
        .addFields(
          { name: 'üõ°Ô∏è Anti-Nuke', value: '`!antinuke <on|off|status>`\nToggle anti-nuke protection system', inline: false },
          { name: 'üö® Anti-Raid', value: '`!antiraid <on|off|status>`\nToggle anti-raid protection system', inline: false },
          { name: 'üìä Raid Threshold', value: '`!antiraid threshold <number>`\nSet raid detection sensitivity', inline: false },
          { name: 'üìÖ Account Age', value: '`!antiraid accountage <days>`\nSet minimum account age requirement', inline: false },
          { name: '‚úÖ Whitelist Users', value: '`!whitelist <add|remove|list> <@user>`\nManage anti-nuke whitelist', inline: false },
          { name: 'ü§ñ Bot Whitelist', value: '`!botwhitelist <add|remove|list> <bot_id>`\n(Owner only) Bots bypass anti-nuke', inline: false },
          { name: 'üë§ User Whitelist', value: '`!userwhitelist <add|remove|list> <@user>`\n(Owner only) Allow adding unverified bots', inline: false },
          { name: 'üîí Quarantine', value: '`!quarantine <add|remove|list> <@user> [reason]`\nPermanent quarantine management', inline: false },
          { name: '‚è∞ Temp Quarantine', value: '`!tempquarantine <add|remove|list> <@user> <time> [reason]`\nTemporary quarantine (e.g., 1h, 2d)', inline: false }
        );
    } else if (category === 'moderation' || category === 'mod') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('‚öîÔ∏è Moderation Commands')
        .setDescription('Comprehensive moderation tools to manage your server members.')
        .addFields(
          { name: 'üî® Ban', value: '`!ban <@user|ID> [reason]`\nPermanently ban a user from the server', inline: false },
          { name: '‚è±Ô∏è Temp Ban', value: '`!tempban <@user|ID> <duration> [reason]`\nTemporarily ban a user (1d, 12h, 30m)', inline: false },
          { name: 'üîì Unban', value: '`!unban <userID>`\nRemove a ban by user ID', inline: false },
          { name: 'üßπ Softban', value: '`!softban <@user> [reason]`\nBan then unban to delete messages', inline: false },
          { name: 'üî® Mass Ban', value: '`!massban <userID> <userID> ...`\nBan multiple users at once', inline: false },
          { name: 'üë¢ Kick', value: '`!kick <@user> [reason]`\nKick a member from the server', inline: false },
          { name: '‚è∞ Timeout', value: '`!timeout <@user> <duration> [reason]`\nTimeout a member (10m, 1h, 1d)', inline: false },
          { name: '‚úÖ Remove Timeout', value: '`!untimeout <@user>`\nRemove timeout from a member', inline: false },
          { name: 'üîá Mute', value: '`!mute <@user> [reason]`\nMute a member with role', inline: false },
          { name: 'üîä Unmute', value: '`!unmute <@user>`\nUnmute a member', inline: false },
          { name: 'üìù Nickname', value: '`!nick <@user> <nickname>`\nChange member nickname', inline: false },
          { name: 'üé≠ Roles', value: '`!role <add|remove> <@user> <@role>`\nManage member roles', inline: false }
        );
    } else if (category === 'warnings' || category === 'warn' || category === 'cases') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('‚ö†Ô∏è Warning & Case Management')
        .setDescription('Advanced warning system and moderation case tracking.')
        .addFields(
          { name: '‚ö†Ô∏è Warn User', value: '`!warn <@user> [reason]`\nIssue a warning to a user', inline: false },
          { name: 'üìã View Warnings', value: '`!warnings <@user>`\nView all warnings for a user', inline: false },
          { name: 'üóëÔ∏è Clear Warnings', value: '`!clearwarnings <@user>`\nClear all warnings for a user', inline: false },
          { name: 'üìù Add Note', value: '`!note <@user> <note>`\nAdd internal moderator note', inline: false },
          { name: 'üìÇ View Case', value: '`!case <caseID>`\nView specific moderation case', inline: false },
          { name: 'üìú User History', value: '`!history <@user>`\nView user moderation history', inline: false },
          { name: '‚úèÔ∏è Edit Reason', value: '`!reason <caseID> <new reason>`\nUpdate case reason', inline: false },
          { name: 'üîç Search Cases', value: '`!search <type|user|mod> <query>`\nSearch moderation cases', inline: false },
          { name: 'üìä Mod Stats', value: '`!modstats [@moderator]`\nView moderation statistics', inline: false },
          { name: 'üì® Appeal', value: '`!appeal <caseID> <reason>`\nAppeal a punishment', inline: false }
        );
    } else if (category === 'channels' || category === 'channel') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üõ°Ô∏è Channel Management')
        .setDescription('Control channel permissions and settings for better moderation.')
        .addFields(
          { name: 'üîí Lock Channel', value: '`!lock [#channel]`\nLock a channel (prevents messages)', inline: false },
          { name: 'üîì Unlock Channel', value: '`!unlock [#channel]`\nUnlock a locked channel', inline: false },
          { name: 'üö® Server Lockdown', value: '`!lockdown`\nLock all channels in the server', inline: false },
          { name: '‚úÖ Remove Lockdown', value: '`!unlockdown`\nUnlock all channels in the server', inline: false },
          { name: '‚è±Ô∏è Slowmode', value: '`!slowmode <seconds> [#channel]`\nSet slowmode (0-21600 seconds)', inline: false }
        );
    } else if (category === 'automod' || category === 'auto') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('ü§ñ Auto-Moderation')
        .setDescription('Automated content filtering and protection systems.')
        .addFields(
          { name: 'ü§ñ Toggle AutoMod', value: '`!automod <on|off>`\nEnable/disable auto-moderation system', inline: false },
          { name: 'üö´ Bad Words', value: '`!badword <add|remove|list> <word>`\nManage bad word filter list', inline: false },
          { name: 'üì¢ Anti-Spam', value: '`!antispam <on|off>`\nToggle anti-spam protection', inline: false },
          { name: 'üîó Anti-Invite', value: '`!antiinvite <on|off>`\nToggle invite link blocker', inline: false },
          { name: 'üîó Anti-Link', value: '`!antilink <on|off>`\nToggle link blocker (with whitelist)', inline: false },
          { name: 'üìã Link Whitelist', value: '`!whitelist <add|remove|list> <domain>`\nManage allowed domains\nExample: `!whitelist add youtube.com`', inline: false },
          { name: '@ Max Mentions', value: '`!maxmentions <number>`\nSet maximum mentions allowed', inline: false }
        );
    } else if (category === 'config' || category === 'configuration' || category === 'settings') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('‚öôÔ∏è Configuration Commands')
        .setDescription('Configure bot settings, log channels, and server preferences.')
        .addFields(
          { name: '`!setlog <#channel>`', value: 'Set general log channel', inline: false },
          { name: '`!setmodlog <#channel>`', value: 'Set moderation log channel', inline: false },
          { name: '`!setjoinlog <#channel>`', value: 'Set join/leave log channel', inline: false },
          { name: '`!setmsglog <#channel>`', value: 'Set message log channel', inline: false },
          { name: '`!modrole <add|remove|list> <@role>`', value: 'Manage moderator roles', inline: false }
        );
    } else if (category === 'utility' || category === 'util' || category === 'info') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üìä Utility Commands')
        .setDescription('Information commands and helpful tools for your server.')
        .addFields(
          { name: 'üèì Ping', value: '`!ping`\nCheck bot latency and response time', inline: false },
          { name: 'üë§ User Info', value: '`!userinfo [@user]`\nView detailed user information', inline: false },
          { name: 'üõ°Ô∏è Server Info', value: '`!serverinfo`\nView server information and stats', inline: false },
          { name: 'üñºÔ∏è Avatar', value: '`!avatar [@user]`\nView user\'s avatar in high quality', inline: false },
          { name: 'üé≠ Role Info', value: '`!roleinfo <@role>`\nView detailed role information', inline: false },
          { name: 'üí§ AFK Status', value: '`!afk [reason]`\nSet your AFK status', inline: false },
          { name: 'üìä Poll', value: '`!poll <question>`\nCreate a poll with reactions', inline: false },
          { name: 'üîó Invite Info', value: '`!inviteinfo`\nView server invite statistics', inline: false },
          { name: 'ü§ñ Bot Info', value: '`!botinfo`\nView bot statistics and info', inline: false }
        );
    } else if (category === 'verification' || category === 'verify') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('‚úÖ Verification Commands')
        .setDescription('Email-based verification system to verify members.')
        .addFields(
          { name: '‚úÖ Verify', value: '`!verify`\nStart email verification process\n(Sends DM with instructions)', inline: false },
          { name: '‚öôÔ∏è Set Verification Role', value: '`!setverify <@role>`\n(Admin) Set which role verified members receive', inline: false }
        );
    } else if (category === 'roles' || category === 'role') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üé≠ Role Management Commands')
        .setDescription('Manage member roles and role assignments.')
        .addFields(
          { name: '‚ûï Add Role', value: '`!addrole <@user> <@role>`\nAdd a role to a member', inline: false },
          { name: '‚ûñ Remove Role', value: '`!removerole <@user> <@role>`\nRemove a role from a member', inline: false },
          { name: 'üìã Role Info', value: '`!roleinfo <@role>`\nView detailed information about a role', inline: false }
        );
    } else if (category === 'server' || category === 'backup') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üíæ Server Management Commands')
        .setDescription('Advanced server backup and restore tools (Server Owner Only).')
        .addFields(
          { name: 'üíæ Backup', value: '`!backup`\nCreate complete server backup\n(channels, categories, permissions, messages)', inline: false },
          { name: '‚è∞ Auto-Backup', value: '`!auto_backup <hours>`\nSchedule automatic backups every X hours\n`!auto_backup off` to disable', inline: false },
          { name: '‚ôªÔ∏è Restore', value: '`!restore [filename]`\nList available backups or restore server', inline: false },
          { name: 'üóëÔ∏è Delete Channels', value: '`!deletechannels confirm`\nDelete all server channels (use with caution)', inline: false }
        );
    } else if (category === 'owner' || category === 'admin' || category === 'developer' || category === 'dev') {
      embed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üîß Developer Commands')
        .setDescription('Exclusive commands for bot developers and administrators.')
        .addFields(
          { name: 'üîó Join Server', value: '`!join <server_id>`\nCreate invite link for any server', inline: false },
          { name: 'üëã Leave Server', value: '`!leave <server_id>`\nMake bot leave a specific server', inline: false },
          { name: 'üîß Maintenance', value: '`!maintenance <on|off>`\nToggle maintenance mode', inline: false },
          { name: 'üö´ Blacklist', value: '`!blacklist <server|user> <ID>`\nBlacklist server or user', inline: false },
          { name: '‚úÖ Unblacklist', value: '`!unblacklist <server|user> <ID>`\nRemove from blacklist', inline: false },
          { name: 'üìã View Blacklists', value: '`!blacklists`\nView all blacklisted entities', inline: false },
          { name: 'üåê Server List', value: '`!servers`\nList all servers bot is in', inline: false },
          { name: 'üì¢ Global Announce', value: '`!announce <message>`\nSend announcement to all servers', inline: false },
          { name: '‚öôÔ∏è Eval Code', value: '`!eval <code>`\nExecute JavaScript code', inline: false }
        );
    } else {
      return message.reply('‚ùå Invalid category. Use `!help` to see all available categories.');
    }

    embed.setFooter({ text: 'Shield Security System | Powered By BotLabs' }).setTimestamp();
    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'slowmode') {
    if (!hasCommandPermission(message.member, message.guild.id, '!slowmode', config, PermissionFlagsBits.ManageChannels)) {
      return message.reply('‚ùå You need manage channels permissions to use this command.');
    }

    const seconds = parseInt(args[0]);
    if (isNaN(seconds) || seconds < 0 || seconds > 21600) {
      return message.reply('‚ùå Please provide a valid number between 0 and 21600 seconds (6 hours).');
    }

    const channel = message.mentions.channels.first() || message.channel;
    await channel.setRateLimitPerUser(seconds);

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle('‚è±Ô∏è Slowmode Updated')
      .setDescription(`**Channel:** ${channel}\n**Slowmode:** ${seconds}s\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Set slowmode to **${seconds}s** in ${channel}`);
  }

  if (commandName === 'lockdown') {
    if (!hasCommandPermission(message.member, message.guild.id, '!lockdown', config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const channels = message.guild.channels.cache.filter(c => c.type === ChannelType.GuildText);
    let locked = 0;

    for (const [, channel] of channels) {
      try {
        await channel.permissionOverwrites.edit(message.guild.id, {
          SendMessages: false
        });
        locked++;
      } catch (err) {}
    }

    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('üîí Server Lockdown Activated')
      .setDescription(`**Locked Channels:** ${locked}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Server lockdown activated! Locked **${locked}** channels.`);
  }

  if (commandName === 'unlockdown') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const channels = message.guild.channels.cache.filter(c => c.type === ChannelType.GuildText);
    let unlocked = 0;

    for (const [, channel] of channels) {
      try {
        await channel.permissionOverwrites.edit(message.guild.id, {
          SendMessages: null
        });
        unlocked++;
      } catch (err) {}
    }

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('üîì Server Lockdown Lifted')
      .setDescription(`**Unlocked Channels:** ${unlocked}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Server lockdown lifted! Unlocked **${unlocked}** channels.`);
  }

  if (commandName === 'mute') {
    if (!hasCommandPermission(message.member, message.guild.id, '!mute', config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const member = message.mentions.members.first();
    if (!member) {
      return message.reply('‚ùå Please mention a member to mute.');
    }

    if (!member.manageable) {
      return message.reply('‚ùå I cannot mute this member.');
    }

    const muteRole = await getMuteRole(message.guild);
    await member.roles.add(muteRole);

    const reason = args.slice(1).join(' ') || 'No reason provided';
    const caseId = await getCaseNumber(message.guild.id);
    
    await addModCase(message.guild.id, {
      caseId,
      type: 'mute',
      userId: member.id,
      userTag: member.user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#808080')
      .setTitle(`üîá User Muted (Case #${caseId})`)
      .setDescription(`**User:** ${member.user.tag} (${member.id})\n**Moderator:** ${message.author.tag}\n**Reason:** ${reason}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully muted **${member.user.tag}** (Case #${caseId})`);
  }

  if (commandName === 'unmute') {
    if (!hasCommandPermission(message.member, message.guild.id, '!unmute', config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const member = message.mentions.members.first();
    if (!member) {
      return message.reply('‚ùå Please mention a member to unmute.');
    }

    const muteRole = await getMuteRole(message.guild);
    await member.roles.remove(muteRole);

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('üîä User Unmuted')
      .setDescription(`**User:** ${member.user.tag} (${member.id})\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully unmuted **${member.user.tag}**`);
  }

  if (commandName === 'softban') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.BanMembers)) {
      return message.reply('‚ùå You need ban permissions to use this command.');
    }

    const member = message.mentions.members.first();
    if (!member) {
      return message.reply('‚ùå Please mention a member to softban.');
    }

    if (!member.bannable) {
      return message.reply('‚ùå I cannot softban this member.');
    }

    const reason = args.slice(1).join(' ') || 'No reason provided';
    const userId = member.id;
    const userTag = member.user.tag;

    await member.ban({ deleteMessageSeconds: 604800, reason: `Softban: ${reason}` });
    await message.guild.members.unban(userId);

    const caseId = await getCaseNumber(message.guild.id);
    await addModCase(message.guild.id, {
      caseId,
      type: 'softban',
      userId: userId,
      userTag: userTag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#FFA500')
      .setTitle(`üßπ User Softbanned (Case #${caseId})`)
      .setDescription(`**User:** ${userTag} (${userId})\n**Moderator:** ${message.author.tag}\n**Reason:** ${reason}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully softbanned **${userTag}** (Case #${caseId})`);
  }

  if (commandName === 'massban') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.BanMembers)) {
      return message.reply('‚ùå You need ban permissions to use this command.');
    }

    if (args.length === 0) {
      return message.reply('‚ùå Please provide user IDs to ban. Usage: `!massban <userID> <userID> ...`');
    }

    const reason = 'Mass ban';
    let banned = 0;
    let failed = 0;

    for (const userId of args) {
      try {
        await message.guild.members.ban(userId, { reason: `${message.author.tag}: ${reason}` });
        const caseId = await getCaseNumber(message.guild.id);
        await addModCase(message.guild.id, {
          caseId,
          type: 'ban',
          userId: userId,
          userTag: 'Unknown',
          moderatorId: message.author.id,
          moderatorTag: message.author.tag,
          reason,
          timestamp: Date.now()
        });
        banned++;
      } catch (err) {
        failed++;
      }
    }

    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('üî® Mass Ban Executed')
      .setDescription(`**Successful:** ${banned}\n**Failed:** ${failed}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Mass ban complete! Banned: **${banned}**, Failed: **${failed}**`);
  }

  if (commandName === 'tempban') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.BanMembers)) {
      return message.reply('‚ùå You need ban permissions to use this command.');
    }

    const user = message.mentions.users.first() || await client.users.fetch(args[0]).catch(() => null);
    if (!user) {
      return message.reply('‚ùå Please mention a user or provide a user ID.');
    }

    const duration = parseDuration(args[1]);
    if (!duration) {
      return message.reply('‚ùå Please provide a valid duration (e.g., 1d, 12h, 30m).');
    }

    const reason = args.slice(2).join(' ') || 'No reason provided';
    const member = message.guild.members.cache.get(user.id);

    if (member && !member.bannable) {
      return message.reply('‚ùå I cannot ban this user.');
    }

    await message.guild.members.ban(user, { reason: `${message.author.tag}: Temporary ban - ${reason}` }).catch(() => {
      return message.reply('‚ùå Failed to ban the user.');
    });

    const unbanTime = Date.now() + (duration * 1000);
    client.tempBans.set(`${message.guild.id}-${user.id}`, {
      guildId: message.guild.id,
      userId: user.id,
      unbanTime: unbanTime,
      duration: duration
    });
    await saveTempBans();

    const caseId = await getCaseNumber(message.guild.id);
    await addModCase(message.guild.id, {
      caseId,
      type: 'tempban',
      userId: user.id,
      userTag: user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      duration: duration,
      unbanTime: unbanTime,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#FF6600')
      .setTitle(`‚è±Ô∏è User Temporarily Banned (Case #${caseId})`)
      .setDescription(`**User:** ${user.tag} (${user.id})\n**Moderator:** ${message.author.tag}\n**Duration:** ${formatDuration(duration)}\n**Reason:** ${reason}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully temp-banned **${user.tag}** for **${formatDuration(duration)}** (Case #${caseId})`);
  }

  if (commandName === 'note') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const user = message.mentions.users.first();
    if (!user) {
      return message.reply('‚ùå Please mention a user.');
    }

    const note = args.slice(1).join(' ');
    if (!note) {
      return message.reply('‚ùå Please provide a note to add.');
    }

    const caseId = await getCaseNumber(message.guild.id);
    await addModCase(message.guild.id, {
      caseId,
      type: 'note',
      userId: user.id,
      userTag: user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason: note,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üìù Mod Note Added (Case #${caseId})`)
      .setDescription(`**User:** ${user.tag} (${user.id})\n**Moderator:** ${message.author.tag}\n**Note:** ${note}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Added mod note for **${user.tag}** (Case #${caseId})`);
  }

  if (commandName === 'reason') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const caseId = parseInt(args[0]);
    if (isNaN(caseId)) {
      return message.reply('‚ùå Please provide a valid case ID.');
    }

    const newReason = args.slice(1).join(' ');
    if (!newReason) {
      return message.reply('‚ùå Please provide a new reason.');
    }

    const success = await updateModCase(message.guild.id, caseId, { reason: newReason, editedBy: message.author.tag, editedAt: Date.now() });
    
    if (success) {
      message.reply(`‚úÖ Updated reason for case #${caseId}`);
      
      const embed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle(`üìù Case Reason Updated (#${caseId})`)
        .setDescription(`**New Reason:** ${newReason}\n**Updated By:** ${message.author.tag}`)
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
    } else {
      message.reply('‚ùå Case not found.');
    }
  }

  if (commandName === 'search') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const searchType = args[0]?.toLowerCase();
    const query = args.slice(1).join(' ');

    if (!searchType || !query) {
      return message.reply('‚ùå Usage: `!search <type|user|mod> <query>`');
    }

    const cases = getModCases(message.guild.id);
    let results = [];

    if (searchType === 'type') {
      results = cases.filter(c => c.type.toLowerCase() === query.toLowerCase());
    } else if (searchType === 'user') {
      const userId = query.replace(/[<@!>]/g, '');
      results = cases.filter(c => c.userId === userId || c.userTag.toLowerCase().includes(query.toLowerCase()));
    } else if (searchType === 'mod') {
      const modId = query.replace(/[<@!>]/g, '');
      results = cases.filter(c => c.moderatorId === modId || c.moderatorTag.toLowerCase().includes(query.toLowerCase()));
    } else {
      return message.reply('‚ùå Invalid search type. Use: type, user, or mod');
    }

    if (results.length === 0) {
      return message.reply('No cases found matching your search.');
    }

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üîç Search Results (${results.length} cases)`)
      .setDescription(results.slice(0, 10).map(c => 
        `**Case #${c.caseId}** - ${c.type.toUpperCase()}\n` +
        `User: ${c.userTag} | Mod: ${c.moderatorTag}\n` +
        `Reason: ${c.reason.substring(0, 50)}${c.reason.length > 50 ? '...' : ''}`
      ).join('\n\n'))
      .setFooter({ text: `Showing first 10 of ${results.length} results | Powered By BotLabs` })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'userinfo') {
    const user = message.mentions.users.first() || message.author;
    const member = message.guild.members.cache.get(user.id);

    if (!member) {
      return message.reply('‚ùå User not found in this server.');
    }

    const cases = getModCases(message.guild.id, user.id);
    const warnings = getWarnings(message.guild.id, user.id);

    const roles = member.roles.cache
      .filter(r => r.id !== message.guild.id)
      .sort((a, b) => b.position - a.position)
      .map(r => r.toString())
      .slice(0, 10)
      .join(', ') || 'None';

    const embed = new EmbedBuilder()
      .setColor('#5865F2')
      .setTitle('üë§ User Information')
      .setDescription(`Information about **${user.tag}**`)
      .setThumbnail(user.displayAvatarURL({ dynamic: true }))
      .addFields(
        { name: 'üÜî User ID', value: `\`${user.id}\``, inline: true },
        { name: 'üìÖ Account Created', value: `<t:${Math.floor(user.createdTimestamp / 1000)}:R>`, inline: true },
        { name: 'üì• Joined Server', value: `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>`, inline: true },
        { name: 'üé≠ Roles', value: roles, inline: false },
        { name: '‚ö†Ô∏è Warnings', value: `\`${warnings.length}\``, inline: true },
        { name: 'üìã Mod Cases', value: `\`${cases.length}\``, inline: true },
        { name: 'üîá Timed Out', value: member.isCommunicationDisabled() ? '`Yes`' : '`No`', inline: true }
      )
      .setFooter({ text: `Requested by ${message.author.tag} | Powered By BotLabs` })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'serverinfo') {
    const guild = message.guild;
    const config = getConfig(guild.id);
    const totalCases = getModCases(guild.id).length;

    const embed = new EmbedBuilder()
      .setColor('#5865F2')
      .setTitle('üõ°Ô∏è Server Information')
      .setDescription(`Information about **${guild.name}**`)
      .setThumbnail(guild.iconURL({ dynamic: true }))
      .addFields(
        { name: 'üÜî Server ID', value: `\`${guild.id}\``, inline: true },
        { name: 'üëë Owner', value: `<@${guild.ownerId}>`, inline: true },
        { name: 'üìÖ Created', value: `<t:${Math.floor(guild.createdTimestamp / 1000)}:R>`, inline: true },
        { name: 'üë• Members', value: `\`${guild.memberCount}\``, inline: true },
        { name: 'üìä Channels', value: `\`${guild.channels.cache.size}\``, inline: true },
        { name: 'üé≠ Roles', value: `\`${guild.roles.cache.size}\``, inline: true },
        { name: 'üõ°Ô∏è Anti-Nuke', value: config.antiNukeEnabled ? '`‚úÖ Enabled`' : '`‚ùå Disabled`', inline: true },
        { name: 'üö® Anti-Raid', value: config.antiRaidEnabled ? '`‚úÖ Enabled`' : '`‚ùå Disabled`', inline: true },
        { name: 'üìã Mod Cases', value: `\`${totalCases}\``, inline: true }
      )
      .setFooter({ text: `Requested by ${message.author.tag} | Powered By BotLabs` })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'modstats') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const targetUser = message.mentions.users.first() || message.author;
    const cases = getModCases(message.guild.id);
    const modCases = cases.filter(c => c.moderatorId === targetUser.id);

    const stats = {
      total: modCases.length,
      ban: modCases.filter(c => c.type === 'ban').length,
      kick: modCases.filter(c => c.type === 'kick').length,
      warn: modCases.filter(c => c.type === 'warn').length,
      timeout: modCases.filter(c => c.type === 'timeout').length,
      mute: modCases.filter(c => c.type === 'mute').length,
      note: modCases.filter(c => c.type === 'note').length,
      softban: modCases.filter(c => c.type === 'softban').length,
      tempban: modCases.filter(c => c.type === 'tempban').length
    };

    const embed = new EmbedBuilder()
      .setColor('#5865F2')
      .setTitle('üìä Moderation Statistics')
      .setDescription(`Moderation stats for **${targetUser.tag}**`)
      .setThumbnail(targetUser.displayAvatarURL({ dynamic: true }))
      .addFields(
        { name: 'üìã Total Actions', value: `\`${stats.total}\``, inline: true },
        { name: 'üî® Bans', value: `\`${stats.ban}\``, inline: true },
        { name: '‚è±Ô∏è Temp Bans', value: `\`${stats.tempban}\``, inline: true },
        { name: 'üë¢ Kicks', value: `\`${stats.kick}\``, inline: true },
        { name: 'üßπ Softbans', value: `\`${stats.softban}\``, inline: true },
        { name: '‚ö†Ô∏è Warnings', value: `\`${stats.warn}\``, inline: true },
        { name: '‚è∞ Timeouts', value: `\`${stats.timeout}\``, inline: true },
        { name: 'üîá Mutes', value: `\`${stats.mute}\``, inline: true },
        { name: 'üìù Notes', value: `\`${stats.note}\``, inline: true }
      )
      .setFooter({ text: `Requested by ${message.author.tag} | Powered By BotLabs` })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'appeal') {
    const caseId = parseInt(args[0]);
    if (isNaN(caseId)) {
      return message.reply('‚ùå Please provide a valid case ID. Usage: `!appeal <caseID> <reason>`');
    }

    const appealReason = args.slice(1).join(' ');
    if (!appealReason) {
      return message.reply('‚ùå Please provide a reason for your appeal.');
    }

    const cases = getModCases(message.guild.id);
    const targetCase = cases.find(c => c.caseId === caseId);

    if (!targetCase) {
      return message.reply('‚ùå Case not found.');
    }

    if (targetCase.userId !== message.author.id) {
      return message.reply('‚ùå You can only appeal your own cases.');
    }

    const appealKey = `${message.guild.id}-${caseId}`;
    if (client.appeals.has(appealKey)) {
      return message.reply('‚ùå An appeal for this case already exists.');
    }

    client.appeals.set(appealKey, {
      guildId: message.guild.id,
      caseId: caseId,
      userId: message.author.id,
      userTag: message.author.tag,
      appealReason: appealReason,
      status: 'pending',
      timestamp: Date.now()
    });
    await saveAppeals();

    message.reply(`‚úÖ Your appeal for case #${caseId} has been submitted and is pending review by moderators.`);

    const embed = new EmbedBuilder()
      .setColor('#FFFF00')
      .setTitle(`üì® New Appeal Submitted - Case #${caseId}`)
      .setDescription(
        `**User:** ${message.author.tag} (${message.author.id})\n` +
        `**Original Case:** #${caseId} (${targetCase.type})\n` +
        `**Original Reason:** ${targetCase.reason}\n` +
        `**Appeal Reason:** ${appealReason}`
      )
      .setFooter({ text: 'Moderators can review this appeal | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
  }

  if (commandName === 'purge' || commandName === 'clear') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageMessages)) {
      return message.reply('‚ùå You need manage messages permissions to use this command.');
    }

    const amount = parseInt(args[0]);
    if (isNaN(amount) || amount < 1 || amount > 100) {
      return message.reply('‚ùå Please provide a number between 1 and 100.');
    }

    try {
      const filter = args[1]?.toLowerCase();
      let messages = await message.channel.messages.fetch({ limit: amount + 1 });
      
      messages = messages.filter(msg => msg.id !== message.id);

      const fourteenDaysAgo = Date.now() - (14 * 24 * 60 * 60 * 1000);
      messages = messages.filter(msg => msg.createdTimestamp > fourteenDaysAgo);

      if (filter === 'bots') {
        messages = messages.filter(msg => msg.author.bot);
      } else if (filter?.startsWith('user:')) {
        const userId = filter.split(':')[1].replace(/[<@!>]/g, '');
        messages = messages.filter(msg => msg.author.id === userId);
      } else if (filter?.startsWith('contains:')) {
        const text = args.slice(1).join(' ').replace('contains:', '');
        messages = messages.filter(msg => msg.content.toLowerCase().includes(text.toLowerCase()));
      }

      if (messages.size === 0) {
        return message.reply('‚ùå No messages found to delete with the specified criteria.');
      }

      const deleted = await message.channel.bulkDelete(messages, true);
      const deletedCount = deleted.size;
      
      const reply = await message.channel.send(`‚úÖ Successfully deleted **${deletedCount}** message(s).`);
      setTimeout(() => {
        message.delete().catch(() => {});
        reply.delete().catch(() => {});
      }, 3000);

      const logEmbed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('üóëÔ∏è Messages Purged')
        .setDescription(`**Moderator:** ${message.author.tag}\n**Channel:** ${message.channel}\n**Amount:** ${deletedCount}\n**Filter:** ${filter || 'none'}`)
        .setTimestamp();

      await logAction(message.guild, logEmbed, 'mod');
    } catch (error) {
      console.error('Purge error:', error);
      return message.reply('‚ùå Failed to purge messages. Make sure the messages are less than 14 days old and I have proper permissions.');
    }
  }

  if (commandName === 'warn') {
    if (!hasCommandPermission(message.member, message.guild.id, '!warn', config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const user = message.mentions.users.first();
    if (!user) {
      return message.reply('‚ùå Please mention a user to warn.');
    }

    const reason = args.slice(1).join(' ') || 'No reason provided';
    
    const warning = {
      reason: reason,
      moderator: message.author.tag,
      timestamp: Date.now()
    };
    
    const warnCount = await addWarning(message.guild.id, user.id, warning);
    const caseId = await getCaseNumber(message.guild.id);
    
    await addModCase(message.guild.id, {
      caseId,
      type: 'warn',
      userId: user.id,
      userTag: user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#FFFF00')
      .setTitle('‚ö†Ô∏è User Warned')
      .setDescription(`Successfully warned **${user.tag}**.`)
      .addFields(
        { name: 'üë§ User', value: `${user.tag}\n\`${user.id}\``, inline: true },
        { name: 'üëÆ Moderator', value: `${message.author.tag}`, inline: true },
        { name: 'üìù Case ID', value: `\`#${caseId}\``, inline: true },
        { name: 'üìä Total Warnings', value: `\`${warnCount}/${config.maxWarnings}\``, inline: true },
        { name: 'üìã Reason', value: reason, inline: false }
      )
      .setFooter({ text: 'Shield Security System | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });

    try {
      await user.send(`‚ö†Ô∏è You have been warned in **${message.guild.name}**\n**Reason:** ${reason}\n**Total Warnings:** ${warnCount}/${config.maxWarnings}`);
    } catch (e) {}

    const member = message.guild.members.cache.get(user.id);
    if (member && warnCount >= config.warnBanThreshold) {
      if (member.bannable) {
        await member.ban({ reason: `Exceeded warning threshold (${warnCount} warnings)` });
        message.channel.send(`üî® **${user.tag}** has been automatically banned for exceeding ${config.warnBanThreshold} warnings.`);
      }
    } else if (member && warnCount >= config.warnKickThreshold) {
      if (member.kickable) {
        await member.kick(`Exceeded warning threshold (${warnCount} warnings)`);
        message.channel.send(`üë¢ **${user.tag}** has been automatically kicked for exceeding ${config.warnKickThreshold} warnings.`);
      }
    }
  }

  if (commandName === 'warnings') {
    const user = message.mentions.users.first() || message.author;
    const warnings = getWarnings(message.guild.id, user.id);

    if (warnings.length === 0) {
      return message.reply(`**${user.tag}** has no warnings.`);
    }

    const embed = new EmbedBuilder()
      .setColor('#FFFF00')
      .setTitle(`‚ö†Ô∏è Warnings for ${user.tag}`)
      .setDescription(warnings.map((w, i) => 
        `**${i + 1}.** ${w.reason}\n**By:** ${w.moderator} | **When:** <t:${Math.floor(w.timestamp / 1000)}:R>`
      ).join('\n\n'))
      .setFooter({ text: `Total: ${warnings.length} warning(s) | Powered By BotLabs` })
      .setTimestamp();

    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'clearwarnings') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need moderate members permissions to use this command.');
    }

    const user = message.mentions.users.first();
    if (!user) {
      return message.reply('‚ùå Please mention a user.');
    }

    await clearWarnings(message.guild.id, user.id);
    message.reply(`‚úÖ Cleared all warnings for **${user.tag}**`);

    const logEmbed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('üóëÔ∏è Warnings Cleared')
      .setDescription(`**User:** ${user.tag}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, logEmbed, 'mod');
  }

  if (commandName === 'nick' || commandName === 'nickname') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageNicknames)) {
      return message.reply('‚ùå You need manage nicknames permissions to use this command.');
    }

    const member = message.mentions.members.first();
    if (!member) {
      return message.reply('‚ùå Please mention a member.');
    }

    if (!member.manageable) {
      return message.reply('‚ùå I cannot change this member\'s nickname.');
    }

    const nickname = args.slice(1).join(' ');
    if (!nickname) {
      return message.reply('‚ùå Please provide a nickname.');
    }

    await member.setNickname(nickname);
    message.reply(`‚úÖ Changed nickname of **${member.user.tag}** to **${nickname}**`);

    const logEmbed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle('üìù Nickname Changed')
      .setDescription(`**User:** ${member.user.tag}\n**New Nickname:** ${nickname}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, logEmbed, 'mod');
  }

  if (commandName === 'resetnick') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageNicknames)) {
      return message.reply('‚ùå You need manage nicknames permissions to use this command.');
    }

    const member = message.mentions.members.first();
    if (!member) {
      return message.reply('‚ùå Please mention a member.');
    }

    if (!member.manageable) {
      return message.reply('‚ùå I cannot change this member\'s nickname.');
    }

    await member.setNickname(null);
    message.reply(`‚úÖ Reset nickname of **${member.user.tag}**`);
  }

  if (commandName === 'role') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageRoles)) {
      return message.reply('‚ùå You need manage roles permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    const member = message.mentions.members.first();
    const role = message.mentions.roles.first();

    if (!action || !member || !role) {
      return message.reply('‚ùå Usage: `!role <add|remove> <@user> <@role>`');
    }

    if (!role.editable) {
      return message.reply('‚ùå I cannot manage this role.');
    }

    if (action === 'add') {
      await member.roles.add(role);
      message.reply(`‚úÖ Added role **${role.name}** to **${member.user.tag}**`);
    } else if (action === 'remove') {
      await member.roles.remove(role);
      message.reply(`‚úÖ Removed role **${role.name}** from **${member.user.tag}**`);
    } else {
      return message.reply('‚ùå Invalid action. Use `add` or `remove`.');
    }
  }

  if (commandName === 'case') {
    const caseId = parseInt(args[0]);
    if (isNaN(caseId)) {
      return message.reply('‚ùå Please provide a valid case ID.');
    }

    const cases = getModCases(message.guild.id);
    const targetCase = cases.find(c => c.caseId === caseId);

    if (!targetCase) {
      return message.reply('‚ùå Case not found.');
    }

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üìã Case #${targetCase.caseId}`)
      .addFields(
        { name: 'Type', value: targetCase.type.toUpperCase(), inline: true },
        { name: 'User', value: `${targetCase.userTag} (${targetCase.userId})`, inline: true },
        { name: 'Moderator', value: targetCase.moderatorTag, inline: true },
        { name: 'Reason', value: targetCase.reason, inline: false },
        { name: 'Date', value: `<t:${Math.floor(targetCase.timestamp / 1000)}:F>`, inline: false }
      );

    if (targetCase.duration) {
      embed.addFields({ name: 'Duration', value: formatDuration(targetCase.duration), inline: true });
    }

    if (targetCase.editedBy) {
      embed.addFields({ name: 'Edited By', value: `${targetCase.editedBy} <t:${Math.floor(targetCase.editedAt / 1000)}:R>`, inline: false });
    }

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'history') {
    const user = message.mentions.users.first();
    if (!user) {
      return message.reply('‚ùå Please mention a user.');
    }

    const cases = getModCases(message.guild.id, user.id);

    if (cases.length === 0) {
      return message.reply(`**${user.tag}** has no moderation history.`);
    }

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üìã Moderation History - ${user.tag}`)
      .setDescription(cases.slice(0, 10).map(c => 
        `**Case #${c.caseId}** - ${c.type.toUpperCase()}\n` +
        `Mod: ${c.moderatorTag} | <t:${Math.floor(c.timestamp / 1000)}:R>\n` +
        `Reason: ${c.reason.substring(0, 50)}${c.reason.length > 50 ? '...' : ''}`
      ).join('\n\n'))
      .setFooter({ text: `Total: ${cases.length} case(s) | Showing first 10 | Powered By BotLabs` })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'automod') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    if (action === 'on' || action === 'enable') {
      config.autoModEnabled = true;
      return message.reply('‚úÖ Auto-moderation has been **enabled**');
    } else if (action === 'off' || action === 'disable') {
      config.autoModEnabled = false;
      return message.reply('‚úÖ Auto-moderation has been **disabled**');
    } else {
      return message.reply('Usage: `!automod <on|off>`');
    }
  }

  if (commandName === 'badword') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      if (config.badWords.size === 0) {
        return message.reply('No bad words configured.');
      }
      const words = Array.from(config.badWords).join(', ');
      return message.reply(`**Bad words:** ${words}`);
    }
    
    const word = args.slice(1).join(' ').toLowerCase();
    
    if (!word) {
      return message.reply('‚ùå Please provide a word.');
    }

    if (action === 'add') {
      config.badWords.add(word);
      config.autoModEnabled = true;
      return message.reply(`‚úÖ Added **${word}** to bad word filter (Auto-mod auto-enabled)`);
    } else if (action === 'remove') {
      config.badWords.delete(word);
      return message.reply(`‚úÖ Removed **${word}** from bad word filter`);
    } else {
      return message.reply('Usage: `!badword <add|remove|list> <word>`');
    }
  }

  if (commandName === 'antispam') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    if (action === 'on' || action === 'enable') {
      config.antiSpamEnabled = true;
      return message.reply('‚úÖ Anti-spam has been **enabled**');
    } else if (action === 'off' || action === 'disable') {
      config.antiSpamEnabled = false;
      return message.reply('‚úÖ Anti-spam has been **disabled**');
    } else {
      return message.reply('Usage: `!antispam <on|off>`');
    }
  }

  if (commandName === 'antiinvite') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    if (action === 'on' || action === 'enable') {
      config.antiInviteEnabled = true;
      return message.reply('‚úÖ Anti-invite has been **enabled**');
    } else if (action === 'off' || action === 'disable') {
      config.antiInviteEnabled = false;
      return message.reply('‚úÖ Anti-invite has been **disabled**');
    } else {
      return message.reply('Usage: `!antiinvite <on|off>`');
    }
  }

  if (commandName === 'antilink') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    if (action === 'on' || action === 'enable') {
      config.antiLinkEnabled = true;
      
      if (!client.linkWhitelists.has(message.guild.id)) {
        client.linkWhitelists.set(message.guild.id, new Set());
      }
      
      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Anti-Link Enabled')
        .setDescription('All links will now be blocked unless their domain is whitelisted.\n\n**To whitelist domains:**\n`!whitelist add <domain>`\n\n**Example:**\n`!whitelist add youtube.com`\n`!whitelist add github.com`')
        .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    } else if (action === 'off' || action === 'disable') {
      config.antiLinkEnabled = false;
      return message.reply('‚úÖ Anti-link has been **disabled**');
    } else {
      return message.reply('Usage: `!antilink <on|off>`');
    }
  }

  if (commandName === 'whitelist') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    
    if (!client.linkWhitelists.has(message.guild.id)) {
      client.linkWhitelists.set(message.guild.id, new Set());
    }
    
    const whitelist = client.linkWhitelists.get(message.guild.id);
    
    if (action === 'list') {
      if (whitelist.size === 0) {
        const embed = new EmbedBuilder()
          .setColor('#FFA500')
          .setTitle('üìã Link Whitelist')
          .setDescription('No domains are whitelisted yet.\n\n**To add domains:**\n`!whitelist add <domain>`\n\n**Example:**\n`!whitelist add youtube.com`')
          .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
          .setTimestamp();
        
        return message.reply({ embeds: [embed] });
      }
      
      const domains = Array.from(whitelist).sort().join('\n‚Ä¢ ');
      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('üìã Link Whitelist')
        .setDescription(`**Whitelisted Domains (${whitelist.size}):**\n‚Ä¢ ${domains}\n\n**Anti-Link Status:** ${config.antiLinkEnabled ? 'üü¢ Enabled' : 'üî¥ Disabled'}`)
        .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }
    
    const domain = args.slice(1).join(' ').toLowerCase().trim();
    
    if (!domain) {
      return message.reply('‚ùå Please provide a domain.\n\nUsage: `!whitelist <add|remove|list> <domain>`\n\n**Examples:**\n`!whitelist add youtube.com`\n`!whitelist remove twitter.com`\n`!whitelist list`');
    }

    const cleanDomain = domain.replace(/^(https?:\/\/)?(www\.)?/, '').replace(/\/.*$/, '');
    
    if (action === 'add') {
      if (whitelist.has(cleanDomain)) {
        return message.reply(`‚ùå **${cleanDomain}** is already whitelisted.`);
      }
      
      whitelist.add(cleanDomain);
      await saveLinkWhitelists();
      
      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Domain Whitelisted')
        .setDescription(`**Domain:** ${cleanDomain}\n**Added by:** ${message.author.tag}\n\nLinks to this domain will now be allowed in the server.`)
        .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
      return message.reply({ embeds: [embed] });
    } else if (action === 'remove') {
      if (!whitelist.has(cleanDomain)) {
        return message.reply(`‚ùå **${cleanDomain}** is not in the whitelist.`);
      }
      
      whitelist.delete(cleanDomain);
      await saveLinkWhitelists();
      
      const embed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('üóëÔ∏è Domain Removed from Whitelist')
        .setDescription(`**Domain:** ${cleanDomain}\n**Removed by:** ${message.author.tag}\n\nLinks to this domain will now be blocked.`)
        .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
      return message.reply({ embeds: [embed] });
    } else {
      return message.reply('Usage: `!whitelist <add|remove|list> <domain>`\n\n**Examples:**\n`!whitelist add youtube.com`\n`!whitelist remove twitter.com`\n`!whitelist list`');
    }
  }

  if (commandName === 'maxmentions') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const amount = parseInt(args[0]);
    if (isNaN(amount) || amount < 1) {
      return message.reply('‚ùå Please provide a valid number.');
    }

    config.maxMentions = amount;
    return message.reply(`‚úÖ Max mentions set to **${amount}**`);
  }

  if (commandName === 'setlog') {
    if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const channel = message.mentions.channels.first() || message.guild.channels.cache.get(args[0]);
    if (!channel) {
      return message.reply('‚ùå Please mention a channel or provide a channel ID.');
    }

    config.logChannel = channel.id;
    return message.reply(`‚úÖ Log channel set to ${channel}`);
  }

  if (commandName === 'setmodlog') {
    if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const channel = message.mentions.channels.first() || message.guild.channels.cache.get(args[0]);
    if (!channel) {
      return message.reply('‚ùå Please mention a channel or provide a channel ID.');
    }

    config.modLogChannel = channel.id;
    return message.reply(`‚úÖ Moderation log channel set to ${channel}`);
  }

  if (commandName === 'setjoinlog') {
    if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const channel = message.mentions.channels.first() || message.guild.channels.cache.get(args[0]);
    if (!channel) {
      return message.reply('‚ùå Please mention a channel or provide a channel ID.');
    }

    config.joinLeaveLogChannel = channel.id;
    return message.reply(`‚úÖ Join/Leave log channel set to ${channel}`);
  }

  if (commandName === 'setmsglog') {
    if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const channel = message.mentions.channels.first() || message.guild.channels.cache.get(args[0]);
    if (!channel) {
      return message.reply('‚ùå Please mention a channel or provide a channel ID.');
    }

    config.messageLogChannel = channel.id;
    return message.reply(`‚úÖ Message log channel set to ${channel}`);
  }

  if (commandName === 'modrole') {
    if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      if (config.moderatorRoles.size === 0) {
        return message.reply('No moderator roles configured. Users with specific Discord permissions can still use moderation commands.');
      }
      const roles = Array.from(config.moderatorRoles).map(id => `<@&${id}>`).join(', ');
      return message.reply(`**Moderator roles:** ${roles}`);
    }
    
    const role = message.mentions.roles.first() || message.guild.roles.cache.get(args[1]);
    
    if (!role) {
      return message.reply('‚ùå Please mention a role or provide a role ID.');
    }

    if (action === 'add') {
      config.moderatorRoles.add(role.id);
      return message.reply(`‚úÖ Added **${role.name}** as a moderator role`);
    } else if (action === 'remove') {
      config.moderatorRoles.delete(role.id);
      return message.reply(`‚úÖ Removed **${role.name}** from moderator roles`);
    } else {
      return message.reply('Usage: `!modrole <add|remove|list> <@role|roleID>`');
    }
  }

  if (commandName === 'ban') {
    if (!hasCommandPermission(message.member, message.guild.id, '!ban', config, PermissionFlagsBits.BanMembers)) {
      return message.reply('‚ùå You need ban permissions to use this command.');
    }

    const user = message.mentions.users.first() || await client.users.fetch(args[0]).catch(() => null);
    if (!user) {
      return message.reply('‚ùå Please mention a user or provide a user ID.');
    }

    const reason = args.slice(1).join(' ') || 'No reason provided';
    const member = message.guild.members.cache.get(user.id);

    if (member && !member.bannable) {
      return message.reply('‚ùå I cannot ban this user. They may have a higher role than me.');
    }

    await message.guild.members.ban(user, { reason: `${message.author.tag}: ${reason}` }).catch(() => {
      return message.reply('‚ùå Failed to ban the user.');
    });

    const caseId = await getCaseNumber(message.guild.id);
    await addModCase(message.guild.id, {
      caseId,
      type: 'ban',
      userId: user.id,
      userTag: user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('üî® User Banned')
      .setDescription(`Successfully banned **${user.tag}** from the server.`)
      .addFields(
        { name: 'üë§ User', value: `${user.tag}\n\`${user.id}\``, inline: true },
        { name: 'üëÆ Moderator', value: `${message.author.tag}`, inline: true },
        { name: 'üìù Case ID', value: `\`#${caseId}\``, inline: true },
        { name: 'üìã Reason', value: reason, inline: false }
      )
      .setFooter({ text: 'Shield Security System | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'unban') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.BanMembers)) {
      return message.reply('‚ùå You need ban permissions to use this command.');
    }

    const userId = args[0];
    if (!userId) {
      return message.reply('‚ùå Please provide a user ID.');
    }

    await message.guild.members.unban(userId).catch(() => {
      return message.reply('‚ùå Failed to unban the user.');
    });

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ User Unbanned')
      .setDescription(`**User ID:** ${userId}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully unbanned user ID **${userId}**`);
  }

  if (commandName === 'kick') {
    if (!hasCommandPermission(message.member, message.guild.id, '!kick', config, PermissionFlagsBits.KickMembers)) {
      return message.reply('‚ùå You need kick permissions to use this command.');
    }

    const member = message.mentions.members.first() || message.guild.members.cache.get(args[0]);
    if (!member) {
      return message.reply('‚ùå Please mention a member or provide a member ID.');
    }

    if (!member.kickable) {
      return message.reply('‚ùå I cannot kick this member. They may have a higher role than me.');
    }

    const reason = args.slice(1).join(' ') || 'No reason provided';
    await member.kick(`${message.author.tag}: ${reason}`).catch(() => {
      return message.reply('‚ùå Failed to kick the member.');
    });

    const caseId = await getCaseNumber(message.guild.id);
    await addModCase(message.guild.id, {
      caseId,
      type: 'kick',
      userId: member.id,
      userTag: member.user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#FFA500')
      .setTitle('üë¢ User Kicked')
      .setDescription(`Successfully kicked **${member.user.tag}** from the server.`)
      .addFields(
        { name: 'üë§ User', value: `${member.user.tag}\n\`${member.id}\``, inline: true },
        { name: 'üëÆ Moderator', value: `${message.author.tag}`, inline: true },
        { name: 'üìù Case ID', value: `\`#${caseId}\``, inline: true },
        { name: 'üìã Reason', value: reason, inline: false }
      )
      .setFooter({ text: 'Shield Security System | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'timeout') {
    if (!hasCommandPermission(message.member, message.guild.id, '!timeout', config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need timeout permissions to use this command.');
    }

    const member = message.mentions.members.first() || message.guild.members.cache.get(args[0]);
    if (!member) {
      return message.reply('‚ùå Please mention a member or provide a member ID.');
    }

    if (!member.moderatable) {
      return message.reply('‚ùå I cannot timeout this member. They may have a higher role than me.');
    }

    let duration = parseDuration(args[1]);
    if (!duration) {
      duration = parseInt(args[1]) * 60;
    }

    if (!duration || duration < 1) {
      return message.reply('‚ùå Please provide a valid duration (e.g., 10m, 1h, 1d)');
    }

    const reason = args.slice(2).join(' ') || 'No reason provided';
    
    await member.timeout(duration * 1000, `${message.author.tag}: ${reason}`).catch(() => {
      return message.reply('‚ùå Failed to timeout the member.');
    });

    const caseId = await getCaseNumber(message.guild.id);
    await addModCase(message.guild.id, {
      caseId,
      type: 'timeout',
      userId: member.id,
      userTag: member.user.tag,
      moderatorId: message.author.id,
      moderatorTag: message.author.tag,
      reason,
      timestamp: Date.now()
    });

    const embed = new EmbedBuilder()
      .setColor('#FFFF00')
      .setTitle('‚è∞ User Timed Out')
      .setDescription(`Successfully timed out **${member.user.tag}**.`)
      .addFields(
        { name: 'üë§ User', value: `${member.user.tag}\n\`${member.id}\``, inline: true },
        { name: 'üëÆ Moderator', value: `${message.author.tag}`, inline: true },
        { name: 'üìù Case ID', value: `\`#${caseId}\``, inline: true },
        { name: '‚è±Ô∏è Duration', value: `\`${args[1]}\``, inline: true },
        { name: 'üìã Reason', value: reason, inline: false }
      )
      .setFooter({ text: 'Shield Security System | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'untimeout') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ModerateMembers)) {
      return message.reply('‚ùå You need timeout permissions to use this command.');
    }

    const member = message.mentions.members.first() || message.guild.members.cache.get(args[0]);
    if (!member) {
      return message.reply('‚ùå Please mention a member or provide a member ID.');
    }

    await member.timeout(null).catch(() => {
      return message.reply('‚ùå Failed to remove timeout.');
    });

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ Timeout Removed')
      .setDescription(`**User:** ${member.user.tag} (${member.id})\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully removed timeout from **${member.user.tag}**`);
  }

  if (commandName === 'lock') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageChannels)) {
      return message.reply('‚ùå You need manage channels permissions to use this command.');
    }

    const channel = message.mentions.channels.first() || message.channel;
    
    await channel.permissionOverwrites.edit(message.guild.id, {
      SendMessages: false
    }).catch(() => {
      return message.reply('‚ùå Failed to lock the channel.');
    });

    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('üîí Channel Locked')
      .setDescription(`**Channel:** ${channel}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully locked ${channel}`);
  }

  if (commandName === 'unlock') {
    if (!hasCommandPermission(message.member, message.guild.id, '!unlock', config, PermissionFlagsBits.ManageChannels)) {
      return message.reply('‚ùå You need manage channels permissions to use this command.');
    }

    const channel = message.mentions.channels.first() || message.channel;
    
    await channel.permissionOverwrites.edit(message.guild.id, {
      SendMessages: null
    }).catch(() => {
      return message.reply('‚ùå Failed to unlock the channel.');
    });

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('üîì Channel Unlocked')
      .setDescription(`**Channel:** ${channel}\n**Moderator:** ${message.author.tag}`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply(`‚úÖ Successfully unlocked ${channel}`);
  }

  if (commandName === 'antinuke') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can toggle anti-nuke protection.');
    }

    const action = args[0]?.toLowerCase();
    if (action === 'on' || action === 'enable') {
      config.antiNukeEnabled = true;
      return message.reply('‚úÖ Anti-nuke protection has been **enabled**');
    } else if (action === 'off' || action === 'disable') {
      config.antiNukeEnabled = false;
      return message.reply('‚úÖ Anti-nuke protection has been **disabled**');
    } else if (action === 'status') {
      return message.reply(`Anti-nuke protection is currently **${config.antiNukeEnabled ? 'enabled' : 'disabled'}**`);
    } else {
      return message.reply('Usage: `!antinuke <enable|disable|status>` (Server owner only)');
    }
  }

  if (commandName === 'antiraid') {
    if (!checkPermissions(message.member, config)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    if (action === 'on' || action === 'enable') {
      config.antiRaidEnabled = true;
      return message.reply('‚úÖ Anti-raid protection has been **enabled**');
    } else if (action === 'off' || action === 'disable') {
      config.antiRaidEnabled = false;
      return message.reply('‚úÖ Anti-raid protection has been **disabled**');
    } else if (action === 'status') {
      const statusEmbed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle('üõ°Ô∏è Anti-Raid Status')
        .addFields(
          { name: 'Status', value: config.antiRaidEnabled ? '‚úÖ Enabled' : '‚ùå Disabled', inline: true },
          { name: 'Join Threshold', value: `${config.raidThreshold} joins`, inline: true },
          { name: 'Time Window', value: `${config.raidTimeWindow / 1000}s`, inline: true },
          { name: 'Min Account Age', value: `${config.accountAgeThreshold} days`, inline: true }
        )
        .setTimestamp();
      return message.reply({ embeds: [statusEmbed] });
    } else if (action === 'threshold') {
      const threshold = parseInt(args[1]);
      if (isNaN(threshold) || threshold < 1) {
        return message.reply('‚ùå Please provide a valid threshold number.');
      }
      config.raidThreshold = threshold;
      return message.reply(`‚úÖ Raid detection threshold set to **${threshold}** joins`);
    } else if (action === 'accountage') {
      const days = parseInt(args[1]);
      if (isNaN(days) || days < 0) {
        return message.reply('‚ùå Please provide a valid number of days.');
      }
      config.accountAgeThreshold = days;
      return message.reply(`‚úÖ Minimum account age set to **${days}** days`);
    } else {
      return message.reply('Usage: `!antiraid <on|off|status|threshold <number>|accountage <days>>`');
    }
  }

  if (commandName === 'whitelist') {
    if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      if (config.whitelistedUsers.size === 0) {
        return message.reply('The whitelist is currently empty.');
      }
      const users = Array.from(config.whitelistedUsers).map(id => `<@${id}>`).join(', ');
      return message.reply(`**Whitelisted users:** ${users}`);
    }
    
    const user = message.mentions.users.first() || await client.users.fetch(args[1]).catch(() => null);
    
    if (!user) {
      return message.reply('‚ùå Please mention a user or provide a user ID.');
    }

    if (action === 'add') {
      config.whitelistedUsers.add(user.id);
      return message.reply(`‚úÖ Added **${user.tag}** to anti-nuke whitelist`);
    } else if (action === 'remove') {
      config.whitelistedUsers.delete(user.id);
      return message.reply(`‚úÖ Removed **${user.tag}** from anti-nuke whitelist`);
    } else {
      return message.reply('Usage: `!whitelist <add|remove|list> <@user|userID>`');
    }
  }

  if (commandName === 'botwhitelist') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can manage the bot whitelist to bypass anti-nuke.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      if (config.whitelistedBots.size === 0) {
        return message.reply('No bots are whitelisted to bypass anti-nuke.\n\n**All bots will be monitored** for dangerous permissions and actions.');
      }
      const bots = Array.from(config.whitelistedBots).map(id => `<@${id}>`).join(', ');
      return message.reply(`**Bots that bypass anti-nuke:** ${bots}\n\nThese bots will NOT be checked by the anti-nuke system.`);
    }
    
    const botId = args[1];
    
    if (!botId) {
      return message.reply('‚ùå Please provide a bot user ID.');
    }

    if (action === 'add') {
      config.whitelistedBots.add(botId);
      return message.reply(`‚úÖ Added bot ID **${botId}** to anti-nuke whitelist\n\nThis bot will bypass all anti-nuke protection checks.`);
    } else if (action === 'remove') {
      config.whitelistedBots.delete(botId);
      return message.reply(`‚úÖ Removed bot ID **${botId}** from anti-nuke whitelist\n\nThis bot will now be monitored by anti-nuke protection.`);
    } else {
      return message.reply('Usage: `!botwhitelist <add|remove|list> <bot_id>`\n\nServer owner only - Allows bots to bypass anti-nuke.');
    }
  }

  if (commandName === 'userwhitelist') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can manage the user whitelist for bot additions.');
    }

    if (!client.userWhitelists.has(message.guild.id)) {
      client.userWhitelists.set(message.guild.id, new Set());
    }
    const whitelist = client.userWhitelists.get(message.guild.id);

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      if (whitelist.size === 0) {
        return message.reply('No users are whitelisted for bot additions.\n\n**Default Policy:** Non-whitelisted admins can only add Discord-verified bots.');
      }
      const users = Array.from(whitelist).map(id => `<@${id}>`).join(', ');
      return message.reply(`**Users whitelisted for bot additions:** ${users}\n\n**Permissions:**\n‚úÖ Can add Discord-verified bots\n‚úÖ Can add unverified bots\n‚ö†Ô∏è Still get quarantined if bot triggers anti-nuke\n\n**Non-whitelisted admins:**\n‚úÖ Can only add Discord-verified bots\nüîí Get quarantined for adding unverified bots`);
    }
    
    const user = message.mentions.users.first() || await client.users.fetch(args[1]).catch(() => null);
    
    if (!user) {
      return message.reply('‚ùå Please mention a user or provide a user ID.');
    }

    if (action === 'add') {
      whitelist.add(user.id);
      await saveUserWhitelists();
      return message.reply(`‚úÖ Added **${user.tag}** to user whitelist\n\n**Permissions granted:**\n‚úÖ Can add Discord-verified bots\n‚úÖ Can add unverified bots\n‚ö†Ô∏è Still gets quarantined if bot triggers anti-nuke`);
    } else if (action === 'remove') {
      whitelist.delete(user.id);
      await saveUserWhitelists();
      return message.reply(`‚úÖ Removed **${user.tag}** from user whitelist\n\nThis user can now only add Discord-verified bots.`);
    } else {
      return message.reply('Usage: `!userwhitelist <add|remove|list> <@user|userID>`\n\nAllows users to add unverified bots (still quarantined if bot nukes).');
    }
  }

  if (commandName === 'quarantine') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      const guildQuarantines = Array.from(client.quarantines.entries())
        .filter(([key]) => key.startsWith(message.guild.id))
        .map(([, data]) => data);
      
      if (guildQuarantines.length === 0) {
        return message.reply('No users are currently quarantined.');
      }
      
      const embed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('üîí Quarantined Users')
        .setDescription(guildQuarantines.map(q => 
          `**<@${q.userId}>**\n` +
          `‚îú Reason: ${q.reason}\n` +
          `‚îú By: ${q.moderator}\n` +
          `‚îú When: <t:${Math.floor(q.timestamp / 1000)}:R>\n` +
          `‚îî Type: ${q.duration ? `Temporary (${formatDuration(q.duration)})` : 'Permanent'}`
        ).join('\n\n'))
        .setFooter({ text: `Total: ${guildQuarantines.length} quarantined | Powered By BotLabs` })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }
    
    const user = message.mentions.users.first() || await client.users.fetch(args[1]).catch(() => null);
    
    if (!user) {
      return message.reply('‚ùå Please mention a user or provide a user ID.');
    }

    const member = await message.guild.members.fetch(user.id).catch(() => null);
    
    if (!member && action === 'add') {
      return message.reply('‚ùå User is not in this server.');
    }

    if (action === 'add') {
      const reason = args.slice(2).join(' ') || 'No reason provided';
      
      if (member.id === message.guild.ownerId) {
        return message.reply('‚ùå Cannot quarantine the server owner.');
      }
      
      if (member.id === message.author.id) {
        return message.reply('‚ùå You cannot quarantine yourself.');
      }
      
      await quarantineUser(message.guild, member, reason);
      
      const embed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('üîí User Quarantined')
        .setDescription(`**User:** ${user.tag}\n**Reason:** ${reason}\n**By:** ${message.author.tag}\n\nAll permissions removed. User can only access quarantine channel.`)
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
      return message.reply({ embeds: [embed] });
    } else if (action === 'remove') {
      const key = `${message.guild.id}-${user.id}`;
      if (!client.quarantines.has(key)) {
        return message.reply('‚ùå This user is not quarantined.');
      }
      
      await unquarantineUser(message.guild, user.id);
      
      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('üîì Quarantine Released')
        .setDescription(`**User:** ${user.tag}\n**Released by:** ${message.author.tag}\n\nAll original permissions restored.`)
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
      return message.reply({ embeds: [embed] });
    } else {
      return message.reply('Usage: `!quarantine <add|remove|list> <@user|userID> [reason]`');
    }
  }

  if (commandName === 'tempquarantine') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'list') {
      const guildQuarantines = Array.from(client.quarantines.entries())
        .filter(([key]) => key.startsWith(message.guild.id))
        .map(([, data]) => data)
        .filter(q => q.duration);
      
      if (guildQuarantines.length === 0) {
        return message.reply('No users are currently in temporary quarantine.');
      }
      
      const now = Date.now();
      const embed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('‚è∞ Temporary Quarantines')
        .setDescription(guildQuarantines.map(q => {
          const remaining = Math.max(0, Math.floor((q.releaseTime - now) / 1000));
          return `**<@${q.userId}>**\n` +
            `‚îú Reason: ${q.reason}\n` +
            `‚îú Duration: ${formatDuration(q.duration)}\n` +
            `‚îî Time Remaining: ${remaining > 0 ? formatDuration(remaining) : 'Releasing...'}`
        }).join('\n\n'))
        .setFooter({ text: `Total: ${guildQuarantines.length} temp quarantines | Powered By BotLabs` })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }
    
    const user = message.mentions.users.first() || await client.users.fetch(args[1]).catch(() => null);
    
    if (!user) {
      return message.reply('‚ùå Please mention a user or provide a user ID.');
    }

    const member = await message.guild.members.fetch(user.id).catch(() => null);
    
    if (!member && action === 'add') {
      return message.reply('‚ùå User is not in this server.');
    }

    if (action === 'add') {
      const durationStr = args[2];
      const duration = parseDuration(durationStr);
      
      if (!duration) {
        return message.reply('‚ùå Invalid duration! Use format: 10m, 1h, 2d, 1w (minutes, hours, days, weeks)');
      }
      
      const reason = args.slice(3).join(' ') || 'No reason provided';
      
      if (member.id === message.guild.ownerId) {
        return message.reply('‚ùå Cannot quarantine the server owner.');
      }
      
      if (member.id === message.author.id) {
        return message.reply('‚ùå You cannot quarantine yourself.');
      }
      
      await quarantineUser(message.guild, member, reason, duration);
      
      const embed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('‚è∞ User Temporarily Quarantined')
        .setDescription(`**User:** ${user.tag}\n**Duration:** ${formatDuration(duration)}\n**Reason:** ${reason}\n**By:** ${message.author.tag}\n\nUser will be automatically released after the duration expires.`)
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
      return message.reply({ embeds: [embed] });
    } else if (action === 'remove') {
      const key = `${message.guild.id}-${user.id}`;
      const quarantineData = client.quarantines.get(key);
      
      if (!quarantineData) {
        return message.reply('‚ùå This user is not quarantined.');
      }
      
      if (!quarantineData.duration) {
        return message.reply('‚ùå This user is in permanent quarantine. Use `!quarantine remove` instead.');
      }
      
      await unquarantineUser(message.guild, user.id);
      
      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('üîì Temporary Quarantine Released Early')
        .setDescription(`**User:** ${user.tag}\n**Released by:** ${message.author.tag}\n\nAll original permissions restored.`)
        .setTimestamp();
      
      await logAction(message.guild, embed, 'mod');
      return message.reply({ embeds: [embed] });
    } else {
      return message.reply('Usage: `!tempquarantine <add|remove|list> <@user|userID> <duration> [reason]`\nExample: `!tempquarantine add @user 1h Added malicious bot`');
    }
  }

  if (commandName === 'botinfo') {
    const embed = new EmbedBuilder()
      .setColor('#5865F2')
      .setTitle('ü§ñ Bot Information')
      .setDescription('Shield Security - Advanced Discord Protection System')
      .addFields(
        { name: 'üìä Servers', value: `\`${client.guilds.cache.size}\``, inline: true },
        { name: 'üë• Total Users', value: `\`${client.guilds.cache.reduce((a, b) => a + b.memberCount, 0)}\``, inline: true },
        { name: '‚è±Ô∏è Uptime', value: `\`${Math.floor(client.uptime / 1000 / 60)} min\``, inline: true },
        { name: 'üíì Ping', value: `\`${Math.round(client.ws.ping)}ms\``, inline: true },
        { name: 'üîß Version', value: '`v1.4.5`', inline: true },
        { name: 'üìù Node.js', value: `\`${process.version}\``, inline: true }
      )
      .setFooter({ text: 'Shield Security System | Powered By BotLabs' })
      .setTimestamp();

    await message.reply({ embeds: [embed] });
  }

  if (commandName === 'maintenance') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const action = args[0]?.toLowerCase();

    if (action === 'on' || action === 'enable') {
      maintenanceMode = true;
      client.user.setActivity('üîß Under Maintenance', { type: ActivityType.Playing });
      message.reply('‚úÖ **Maintenance mode enabled.** Bot commands are now disabled for all users except you.');
      console.log('üîß Maintenance mode activated');
    } else if (action === 'off' || action === 'disable') {
      maintenanceMode = false;
      const totalMembers = client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0);
      client.user.setActivity(`Shielding ${client.guilds.cache.size} servers And ${totalMembers} members`, { type: ActivityType.Watching });
      message.reply('‚úÖ **Maintenance mode disabled.** Bot is now fully operational.');
      console.log('‚úÖ Maintenance mode deactivated');
    } else {
      return message.reply('Usage: `!maintenance <on|off>`');
    }
  }

  if (commandName === 'blacklist') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const type = args[0]?.toLowerCase();
    const id = args[1];

    if (!type || !id) {
      return message.reply('Usage: `!blacklist <server|user> <ID>`');
    }

    if (type === 'server' || type === 'guild') {
      client.blacklistedServers.add(id);
      await saveBlacklist();
      const guild = client.guilds.cache.get(id);
      message.reply(`‚úÖ Blacklisted server: ${guild ? guild.name : id}`);
      if (guild) {
        await guild.leave().catch(() => {});
      }
    } else if (type === 'user') {
      client.blacklistedUsers.add(id);
      await saveBlacklist();
      const user = await client.users.fetch(id).catch(() => null);
      message.reply(`‚úÖ Blacklisted user: ${user ? user.tag : id}`);
    } else {
      return message.reply('‚ùå Invalid type. Use: server or user');
    }
  }

  if (commandName === 'unblacklist') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const type = args[0]?.toLowerCase();
    const id = args[1];

    if (!type || !id) {
      return message.reply('Usage: `!unblacklist <server|user> <ID>`');
    }

    if (type === 'server' || type === 'guild') {
      client.blacklistedServers.delete(id);
      await saveBlacklist();
      message.reply(`‚úÖ Removed server from blacklist: ${id}`);
    } else if (type === 'user') {
      client.blacklistedUsers.delete(id);
      await saveBlacklist();
      message.reply(`‚úÖ Removed user from blacklist: ${id}`);
    } else {
      return message.reply('‚ùå Invalid type. Use: server or user');
    }
  }

  if (commandName === 'blacklistinfo' || commandName === 'blacklists') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const serverList = Array.from(client.blacklistedServers).slice(0, 10).join('\n') || 'None';
    const userList = Array.from(client.blacklistedUsers).slice(0, 10).join('\n') || 'None';

    const embed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('üö´ Blacklist Information')
      .addFields(
        { name: `Blacklisted Servers (${client.blacklistedServers.size})`, value: serverList, inline: false },
        { name: `Blacklisted Users (${client.blacklistedUsers.size})`, value: userList, inline: false }
      )
      .setFooter({ text: 'Showing first 10 entries per category | Powered By BotLabs' })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'servers' || commandName === 'serverlist') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const servers = client.guilds.cache
      .sort((a, b) => b.memberCount - a.memberCount)
      .map((guild, index) => `${index + 1}. **${guild.name}** (${guild.id})\n   Members: ${guild.memberCount}`)
      .slice(0, 20)
      .join('\n');

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üåê Server List (${client.guilds.cache.size} total)`)
      .setDescription(servers || 'No servers')
      .setFooter({ text: 'Showing top 20 servers by member count | Powered By BotLabs' })
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'leaveserver') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const guildId = args[0];
    if (!guildId) {
      return message.reply('Usage: `!leaveserver <serverID>`');
    }

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
      return message.reply('‚ùå Server not found.');
    }

    const guildName = guild.name;
    await guild.leave();
    message.reply(`‚úÖ Left server: **${guildName}** (${guildId})`);
  }

  if (commandName === 'announce' || commandName === 'globalannounce') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const announcement = args.join(' ');
    if (!announcement) {
      return message.reply('Usage: `!announce <message>`');
    }

    let sent = 0;
    let failed = 0;

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle('üì¢ Bot Announcement')
      .setDescription(announcement)
      .setFooter({ text: `Sent by ${message.author.tag} | Powered By BotLabs` })
      .setTimestamp();

    for (const [, guild] of client.guilds.cache) {
      try {
        const config = getConfig(guild.id);
        let targetChannel = null;

        if (config.logChannel) {
          targetChannel = guild.channels.cache.get(config.logChannel);
        }

        if (!targetChannel || !targetChannel.isTextBased()) {
          const textChannels = guild.channels.cache.filter(c => 
            c.isTextBased() && 
            c.permissionsFor(guild.members.me).has(PermissionFlagsBits.SendMessages)
          );
          
          targetChannel = textChannels.find(c => 
            c.name.includes('general') || 
            c.name.includes('chat') || 
            c.name.includes('announcement')
          ) || textChannels.first();
        }

        if (targetChannel && targetChannel.isTextBased()) {
          await targetChannel.send({ embeds: [embed] });
          sent++;
        } else {
          failed++;
        }
      } catch (error) {
        failed++;
      }
    }

    message.reply(`‚úÖ Announcement sent to **${sent}** servers. Failed: **${failed}**`);
  }

  if (commandName === 'eval') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot owner only.');
    }

    const code = args.join(' ');
    if (!code) {
      return message.reply('Usage: `!eval <code>`');
    }

    try {
      let evaled = eval(code);
      if (typeof evaled !== 'string') {
        evaled = require('util').inspect(evaled);
      }

      if (evaled.length > 1900) {
        evaled = evaled.substring(0, 1900) + '...';
      }

      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Eval Success')
        .addFields(
          { name: 'Input', value: `\`\`\`js\n${code.substring(0, 1000)}\`\`\``, inline: false },
          { name: 'Output', value: `\`\`\`js\n${evaled}\`\`\``, inline: false }
        )
        .setTimestamp();

      message.reply({ embeds: [embed] });
    } catch (err) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Eval Error')
        .addFields(
          { name: 'Input', value: `\`\`\`js\n${code.substring(0, 1000)}\`\`\``, inline: false },
          { name: 'Error', value: `\`\`\`js\n${err.toString().substring(0, 1000)}\`\`\``, inline: false }
        )
        .setTimestamp();

      message.reply({ embeds: [embed] });
    }
  }

  if (commandName === 'join') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot developer only.');
    }

    const serverId = args[0];
    if (!serverId) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Invalid Usage')
        .setDescription('Please provide a server ID.')
        .addFields(
          { name: 'üìã Usage', value: '`!join <server_id>`', inline: false },
          { name: 'üìù Example', value: '`!join 123456789012345678`', inline: false }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }

    const guild = client.guilds.cache.get(serverId);
    if (!guild) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Server Not Found')
        .setDescription(`Could not find a server with ID: \`${serverId}\``)
        .addFields(
          { name: 'üí° Possible Reasons', value: '‚Ä¢ Bot is not in that server\n‚Ä¢ Invalid server ID\n‚Ä¢ Server no longer exists', inline: false }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }

    try {
      const channels = guild.channels.cache.filter(c => c.type === ChannelType.GuildText);
      const firstChannel = channels.find(c => 
        c.permissionsFor(guild.members.me).has(PermissionFlagsBits.CreateInstantInvite)
      );

      if (!firstChannel) {
        const embed = new EmbedBuilder()
          .setColor('#FFA500')
          .setTitle('‚ö†Ô∏è Permission Error')
          .setDescription(`Bot doesn't have permission to create invites in **${guild.name}**`)
          .addFields(
            { name: 'üè¢ Server Name', value: guild.name, inline: true },
            { name: 'üÜî Server ID', value: serverId, inline: true },
            { name: 'üë• Members', value: guild.memberCount.toString(), inline: true }
          )
          .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
          .setTimestamp();
        
        return message.reply({ embeds: [embed] });
      }

      const invite = await firstChannel.createInvite({
        maxAge: 0,
        maxUses: 0,
        reason: 'Developer invite link created'
      });

      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Invite Link Created')
        .setDescription(`Successfully created an invite link for **${guild.name}**`)
        .addFields(
          { name: 'üîó Invite Link', value: `[Click Here](${invite.url})\n\`\`\`${invite.url}\`\`\``, inline: false },
          { name: 'üè¢ Server Name', value: guild.name, inline: true },
          { name: 'üÜî Server ID', value: serverId, inline: true },
          { name: 'üë• Members', value: guild.memberCount.toString(), inline: true },
          { name: '‚è∞ Expires', value: 'Never', inline: true },
          { name: 'üî¢ Max Uses', value: 'Unlimited', inline: true },
          { name: 'üìç Channel', value: firstChannel.toString(), inline: true }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();

      await message.reply({ embeds: [embed] });
    } catch (error) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Error Creating Invite')
        .setDescription(`Failed to create invite link for **${guild.name}**`)
        .addFields(
          { name: '‚ö†Ô∏è Error', value: `\`\`\`${error.message}\`\`\``, inline: false }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();
      
      message.reply({ embeds: [embed] });
    }
  }

  if (commandName === 'leave') {
    if (!isOwner(message.author.id)) {
      return message.reply('‚ùå This command is restricted to the bot developer only.');
    }

    const serverId = args[0];
    if (!serverId) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Invalid Usage')
        .setDescription('Please provide a server ID.')
        .addFields(
          { name: 'üìã Usage', value: '`!leave <server_id>`', inline: false },
          { name: 'üìù Example', value: '`!leave 123456789012345678`', inline: false }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }

    const guild = client.guilds.cache.get(serverId);
    if (!guild) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Server Not Found')
        .setDescription(`Could not find a server with ID: \`${serverId}\``)
        .addFields(
          { name: 'üí° Possible Reasons', value: '‚Ä¢ Bot is not in that server\n‚Ä¢ Invalid server ID\n‚Ä¢ Server no longer exists', inline: false }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();
      
      return message.reply({ embeds: [embed] });
    }

    const guildName = guild.name;
    const memberCount = guild.memberCount;

    try {
      await guild.leave();
      
      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Successfully Left Server')
        .setDescription(`Bot has left **${guildName}**`)
        .addFields(
          { name: 'üè¢ Server Name', value: guildName, inline: true },
          { name: 'üÜî Server ID', value: serverId, inline: true },
          { name: 'üë• Members', value: memberCount.toString(), inline: true },
          { name: 'üìä Remaining Servers', value: client.guilds.cache.size.toString(), inline: true }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();

      await message.reply({ embeds: [embed] });
    } catch (error) {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ùå Error Leaving Server')
        .setDescription(`Failed to leave **${guildName}**`)
        .addFields(
          { name: '‚ö†Ô∏è Error', value: `\`\`\`${error.message}\`\`\``, inline: false }
        )
        .setFooter({ text: 'Shield Security - Developer Commands | Powered By BotLabs' })
        .setTimestamp();
      
      message.reply({ embeds: [embed] });
    }
  }

  if (commandName === 'prefix') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to change the server prefix.');
    }

    const newPrefix = args[0];
    if (!newPrefix) {
      const currentPrefix = getPrefix(message.guild.id);
      return message.reply(`üìå Current server prefix: \`${currentPrefix}\`\nUsage: \`${currentPrefix}prefix <new_prefix>\``);
    }

    if (newPrefix.length > 5) {
      return message.reply('‚ùå Prefix must be 5 characters or less.');
    }

    client.serverPrefixes.set(message.guild.id, newPrefix);
    await saveServerPrefixes();

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ Prefix Updated')
      .setDescription(`**New Prefix:** \`${newPrefix}\`\n**Set by:** ${message.author.tag}\n\nAll commands now use this prefix.`)
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'quarantine_roleset') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to set the quarantine role.');
    }

    const role = message.mentions.roles.first();
    if (!role) {
      return message.reply(`‚ùå Please mention a role to use for quarantine.\nUsage: \`${getPrefix(message.guild.id)}quarantine_roleset @role\``);
    }

    client.quarantineRoles.set(message.guild.id, role.id);
    await saveQuarantineRoles();

    const embed = new EmbedBuilder()
      .setColor('#FFA500')
      .setTitle('üîí Quarantine Role Set')
      .setDescription(`**Role:** ${role}\n**Set by:** ${message.author.tag}\n\nUsers who are quarantined will now be assigned this role (all other roles removed).`)
      .setFooter({ text: 'Make sure this role has ViewChannel denied for most channels | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'verification_roleset') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to set the verification role.');
    }

    const role = message.mentions.roles.first();
    if (!role) {
      return message.reply(`‚ùå Please mention a role to assign after email verification.\nUsage: \`${getPrefix(message.guild.id)}verification_roleset @role\``);
    }

    client.verificationRoles.set(message.guild.id, role.id);
    await saveVerificationRoles();

    const embed = new EmbedBuilder()
      .setColor('#0099FF')
      .setTitle('‚úâÔ∏è Verification Role Set')
      .setDescription(`**Role:** ${role}\n**Set by:** ${message.author.tag}\n\nUsers who complete email verification will receive this role.`)
      .setFooter({ text: 'Users can verify with the !verify command | v1.4.5 | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'reactionrole') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to set up reaction roles.');
    }

    const subCommand = args[0];
    
    if (subCommand === 'create') {
      const messageId = args[1];
      if (!messageId) {
        return message.reply(`‚ùå Please provide a message ID.\nUsage: \`${getPrefix(message.guild.id)}reactionrole create <messageId>\``);
      }

      let targetMessage;
      try {
        targetMessage = await message.channel.messages.fetch(messageId);
      } catch (error) {
        return message.reply('‚ùå Could not find that message in this channel.');
      }

      client.reactionRoles.set(messageId, {
        guildId: message.guild.id,
        channelId: message.channel.id,
        roles: new Map()
      });
      await saveReactionRoles();

      return message.reply(`‚úÖ Reaction role message created!\n\nNow add emoji-role pairs using:\n\`${getPrefix(message.guild.id)}reactionrole add ${messageId} <emoji> @role\`\n\n*You can add up to 15 emoji-role pairs.*`);
    }

    if (subCommand === 'add') {
      const messageId = args[1];
      const emoji = args[2];
      const role = message.mentions.roles.first();

      if (!messageId || !emoji || !role) {
        return message.reply(`‚ùå Usage: \`${getPrefix(message.guild.id)}reactionrole add <messageId> <emoji> @role\``);
      }

      const reactionRoleData = client.reactionRoles.get(messageId);
      if (!reactionRoleData) {
        return message.reply('‚ùå That message is not set up for reaction roles. Use `reactionrole create` first.');
      }

      if (reactionRoleData.roles.size >= 15) {
        return message.reply('‚ùå Maximum of 15 reaction roles per message reached.');
      }

      reactionRoleData.roles.set(emoji, role.id);
      client.reactionRoles.set(messageId, reactionRoleData);
      await saveReactionRoles();

      let targetMessage;
      try {
        const channel = await client.channels.fetch(reactionRoleData.channelId);
        targetMessage = await channel.messages.fetch(messageId);
        await targetMessage.react(emoji);
      } catch (error) {
        console.error('Failed to add reaction:', error);
      }

      return message.reply(`‚úÖ Added reaction role: ${emoji} ‚Üí ${role}\n\n**Total pairs:** ${reactionRoleData.roles.size}/15`);
    }

    if (subCommand === 'remove') {
      const messageId = args[1];
      const emoji = args[2];

      if (!messageId || !emoji) {
        return message.reply(`‚ùå Usage: \`${getPrefix(message.guild.id)}reactionrole remove <messageId> <emoji>\``);
      }

      const reactionRoleData = client.reactionRoles.get(messageId);
      if (!reactionRoleData) {
        return message.reply('‚ùå That message is not set up for reaction roles.');
      }

      if (!reactionRoleData.roles.has(emoji)) {
        return message.reply('‚ùå That emoji is not configured for this message.');
      }

      reactionRoleData.roles.delete(emoji);
      client.reactionRoles.set(messageId, reactionRoleData);
      await saveReactionRoles();

      return message.reply(`‚úÖ Removed reaction role for ${emoji}`);
    }

    if (subCommand === 'list') {
      const messageId = args[1];
      if (!messageId) {
        return message.reply(`‚ùå Usage: \`${getPrefix(message.guild.id)}reactionrole list <messageId>\``);
      }

      const reactionRoleData = client.reactionRoles.get(messageId);
      if (!reactionRoleData || reactionRoleData.roles.size === 0) {
        return message.reply('‚ùå No reaction roles configured for that message.');
      }

      const roleList = Array.from(reactionRoleData.roles.entries())
        .map(([emoji, roleId]) => {
          const role = message.guild.roles.cache.get(roleId);
          return `${emoji} ‚Üí ${role || 'Deleted Role'}`;
        })
        .join('\n');

      const embed = new EmbedBuilder()
        .setColor('#0099FF')
        .setTitle('üé≠ Reaction Roles')
        .setDescription(`**Message ID:** \`${messageId}\`\n\n${roleList}\n\n**Total:** ${reactionRoleData.roles.size}/15`)
        .setTimestamp();

      return message.reply({ embeds: [embed] });
    }

    return message.reply(`‚ùå Invalid subcommand.\n\n**Usage:**\n\`${getPrefix(message.guild.id)}reactionrole create <messageId>\`\n\`${getPrefix(message.guild.id)}reactionrole add <messageId> <emoji> @role\`\n\`${getPrefix(message.guild.id)}reactionrole remove <messageId> <emoji>\`\n\`${getPrefix(message.guild.id)}reactionrole list <messageId>\``);
  }

  if (commandName === 'autorole') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to configure autorole.');
    }

    const subCommand = args[0];

    if (subCommand === 'set') {
      const role = message.mentions.roles.first();
      if (!role) {
        return message.reply(`‚ùå Please mention a role to auto-assign.\nUsage: \`${getPrefix(message.guild.id)}autorole set @role\``);
      }

      const settings = client.autoroleSettings.get(message.guild.id) || {
        roleId: null,
        requireNotTimedOut: false,
        joinDelayMinutes: 0,
        requireVerified: false
      };

      settings.roleId = role.id;
      client.autoroleSettings.set(message.guild.id, settings);
      await saveAutoroleSettings();

      const verificationEnabled = client.verificationRoles.has(message.guild.id);
      let warningMessage = '';
      if (verificationEnabled && !settings.requireVerified) {
        warningMessage = '\n\n‚ö†Ô∏è **Warning:** Email verification is enabled but autorole is not set to require verification. This may conflict. Consider using `!autorole require_verified true` to ensure only verified users get the autorole.';
      }

      return message.reply(`‚úÖ Autorole set to: ${role}\n\nUse \`${getPrefix(message.guild.id)}autorole conditions\` to configure conditions.${warningMessage}`);
    }

    if (subCommand === 'conditions') {
      const settings = client.autoroleSettings.get(message.guild.id);
      if (!settings || !settings.roleId) {
        return message.reply('‚ùå No autorole is set. Use `autorole set` first.');
      }

      const role = message.guild.roles.cache.get(settings.roleId);
      const embed = new EmbedBuilder()
        .setColor('#0099FF')
        .setTitle('‚öôÔ∏è Autorole Conditions')
        .setDescription(`**Role:** ${role || 'Deleted Role'}\n\n**Current Conditions:**`)
        .addFields(
          { name: 'Require Not Timed Out', value: settings.requireNotTimedOut ? '‚úÖ Enabled' : '‚ùå Disabled', inline: true },
          { name: 'Join Delay', value: settings.joinDelayMinutes > 0 ? `‚è±Ô∏è ${settings.joinDelayMinutes} minutes` : '‚ùå Instant', inline: true },
          { name: 'Require Verified', value: settings.requireVerified ? '‚úÖ Enabled' : '‚ùå Disabled', inline: true }
        )
        .setFooter({ text: `Configure with: ${getPrefix(message.guild.id)}autorole <condition> <value> | Powered By BotLabs` })
        .setTimestamp();

      return message.reply({ embeds: [embed] });
    }

    if (subCommand === 'require_not_timed_out') {
      const value = args[1]?.toLowerCase();
      if (!['true', 'false'].includes(value)) {
        return message.reply('‚ùå Please specify `true` or `false`.');
      }

      const settings = client.autoroleSettings.get(message.guild.id);
      if (!settings || !settings.roleId) {
        return message.reply('‚ùå No autorole is set. Use `autorole set` first.');
      }

      settings.requireNotTimedOut = value === 'true';
      client.autoroleSettings.set(message.guild.id, settings);
      await saveAutoroleSettings();

      return message.reply(`‚úÖ Autorole will ${settings.requireNotTimedOut ? 'only' : 'also'} be assigned to members ${settings.requireNotTimedOut ? 'not in timeout' : 'even if timed out'}.`);
    }

    if (subCommand === 'join_delay') {
      const minutes = parseInt(args[1]);
      if (isNaN(minutes) || minutes < 0 || minutes > 1440) {
        return message.reply('‚ùå Please specify a valid delay in minutes (0-1440).');
      }

      const settings = client.autoroleSettings.get(message.guild.id);
      if (!settings || !settings.roleId) {
        return message.reply('‚ùå No autorole is set. Use `autorole set` first.');
      }

      settings.joinDelayMinutes = minutes;
      client.autoroleSettings.set(message.guild.id, settings);
      await saveAutoroleSettings();

      return message.reply(`‚úÖ Autorole will be assigned ${minutes > 0 ? `**${minutes} minutes** after joining` : '**immediately** upon joining'}.`);
    }

    if (subCommand === 'require_verified') {
      const value = args[1]?.toLowerCase();
      if (!['true', 'false'].includes(value)) {
        return message.reply('‚ùå Please specify `true` or `false`.');
      }

      const settings = client.autoroleSettings.get(message.guild.id);
      if (!settings || !settings.roleId) {
        return message.reply('‚ùå No autorole is set. Use `autorole set` first.');
      }

      settings.requireVerified = value === 'true';
      client.autoroleSettings.set(message.guild.id, settings);
      await saveAutoroleSettings();

      return message.reply(`‚úÖ Autorole will ${settings.requireVerified ? 'only' : 'also'} be assigned to ${settings.requireVerified ? 'verified members' : 'all members'}.`);
    }

    if (subCommand === 'disable') {
      client.autoroleSettings.delete(message.guild.id);
      await saveAutoroleSettings();
      return message.reply('‚úÖ Autorole has been disabled for this server.');
    }

    return message.reply(`‚ùå Invalid subcommand.\n\n**Usage:**\n\`${getPrefix(message.guild.id)}autorole set @role\`\n\`${getPrefix(message.guild.id)}autorole conditions\`\n\`${getPrefix(message.guild.id)}autorole require_not_timed_out <true/false>\`\n\`${getPrefix(message.guild.id)}autorole join_delay <minutes>\`\n\`${getPrefix(message.guild.id)}autorole require_verified <true/false>\`\n\`${getPrefix(message.guild.id)}autorole disable\``);
  }

  if (commandName === 'afk') {
    const reason = args.join(' ') || 'AFK';
    client.afkUsers.set(message.author.id, { reason, timestamp: Date.now() });
    message.reply(`‚úÖ Your AFK status has been set: **${reason}**`);
  }

  if (commandName === 'poll') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageMessages)) {
      return message.reply('‚ùå You need manage messages permissions to use this command.');
    }

    const question = args.join(' ');
    if (!question) {
      return message.reply('Usage: `!poll <question>`');
    }

    const embed = new EmbedBuilder()
      .setColor('#5865F2')
      .setTitle('üìä Poll')
      .setDescription(question)
      .addFields(
        { name: 'üìù How to Vote', value: 'React with üëç for yes, üëé for no, or ü§∑ for unsure', inline: false }
      )
      .setFooter({ text: `Poll by ${message.author.tag} | Powered By BotLabs` })
      .setTimestamp();

    const pollMsg = await message.channel.send({ embeds: [embed] });
    await pollMsg.react('üëç');
    await pollMsg.react('üëé');
    await pollMsg.react('ü§∑');
    
    message.delete().catch(() => {});
  }

  if (commandName === 'inviteinfo') {
    const invites = await message.guild.invites.fetch().catch(() => null);
    
    if (!invites) {
      return message.reply('‚ùå Unable to fetch server invites.');
    }

    const totalInvites = invites.reduce((acc, invite) => acc + (invite.uses || 0), 0);
    const activeInvites = invites.filter(i => !i.expiresAt || i.expiresAt > Date.now()).size;

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle('üîó Server Invite Information')
      .addFields(
        { name: 'Total Invites', value: invites.size.toString(), inline: true },
        { name: 'Active Invites', value: activeInvites.toString(), inline: true },
        { name: 'Total Uses', value: totalInvites.toString(), inline: true }
      )
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'avatar') {
    const user = message.mentions.users.first() || message.author;
    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`${user.tag}'s Avatar`)
      .setImage(user.displayAvatarURL({ dynamic: true, size: 1024 }))
      .setTimestamp();
    
    message.reply({ embeds: [embed] });
  }

  if (commandName === 'roleinfo') {
    const role = message.mentions.roles.first();
    if (!role) {
      return message.reply('‚ùå Please mention a role.');
    }

    const embed = new EmbedBuilder()
      .setColor(role.color)
      .setTitle(`üé≠ Role Information - ${role.name}`)
      .addFields(
        { name: 'üÜî Role ID', value: role.id, inline: true },
        { name: 'üé® Color', value: role.hexColor, inline: true },
        { name: 'üë• Members', value: role.members.size.toString(), inline: true },
        { name: 'üìä Position', value: role.position.toString(), inline: true },
        { name: 'üìå Hoisted', value: role.hoist ? 'Yes' : 'No', inline: true },
        { name: 'üîñ Mentionable', value: role.mentionable ? 'Yes' : 'No', inline: true },
        { name: 'üìÖ Created', value: `<t:${Math.floor(role.createdTimestamp / 1000)}:R>`, inline: true }
      )
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'backup') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can create backups.');
    }

    const statusMsg = await message.reply('‚è≥ Creating server backup... This may take a while.');

    try {
      const backupData = {
        guildId: message.guild.id,
        guildName: message.guild.name,
        timestamp: Date.now(),
        categories: [],
        textChannels: [],
        voiceChannels: []
      };

      for (const [id, channel] of message.guild.channels.cache) {
        if (channel.type === ChannelType.GuildCategory) {
          backupData.categories.push({
            id: channel.id,
            name: channel.name,
            position: channel.position,
            permissions: channel.permissionOverwrites.cache.map(p => ({
              id: p.id,
              type: p.type,
              allow: p.allow.bitfield.toString(),
              deny: p.deny.bitfield.toString()
            }))
          });
        } else if (channel.type === ChannelType.GuildText) {
          const channelData = {
            id: channel.id,
            name: channel.name,
            position: channel.position,
            topic: channel.topic,
            nsfw: channel.nsfw,
            parentId: channel.parentId,
            permissions: channel.permissionOverwrites.cache.map(p => ({
              id: p.id,
              type: p.type,
              allow: p.allow.bitfield.toString(),
              deny: p.deny.bitfield.toString()
            })),
            messages: []
          };

          try {
            const messages = await channel.messages.fetch({ limit: 100 });
            channelData.messages = messages.map(m => ({
              author: m.author.tag,
              authorId: m.author.id,
              authorAvatar: m.author.displayAvatarURL({ dynamic: true }),
              content: m.content,
              timestamp: m.createdTimestamp,
              attachments: m.attachments.map(a => ({ url: a.url, name: a.name })),
              embeds: m.embeds.map(e => e.toJSON()),
              isWebhook: m.webhookId !== null,
              webhookId: m.webhookId,
              webhookName: m.webhookId ? m.author.username : null,
              webhookAvatar: m.webhookId ? m.author.displayAvatarURL({ dynamic: true }) : null
            })).reverse();
          } catch (e) {
            console.log(`Could not fetch messages from ${channel.name}:`, e.message);
          }

          backupData.textChannels.push(channelData);
        } else if (channel.type === ChannelType.GuildVoice) {
          backupData.voiceChannels.push({
            id: channel.id,
            name: channel.name,
            position: channel.position,
            bitrate: channel.bitrate,
            userLimit: channel.userLimit,
            parentId: channel.parentId,
            permissions: channel.permissionOverwrites.cache.map(p => ({
              id: p.id,
              type: p.type,
              allow: p.allow.bitfield.toString(),
              deny: p.deny.bitfield.toString()
            }))
          });
        }
      }

      const backupDir = path.join(__dirname, 'backups', message.guild.id);
      await fs.mkdir(backupDir, { recursive: true });
      
      const sanitizedName = message.guild.name.replace(/[^a-z0-9]/gi, '_');
      const fileName = `${sanitizedName}_backup_${Date.now()}.json`;
      const filePath = path.join(backupDir, fileName);
      await fs.writeFile(filePath, JSON.stringify(backupData, null, 2));

      const totalMessages = backupData.textChannels.reduce((sum, ch) => sum + ch.messages.length, 0);

      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Server Backup Created')
        .setDescription(`**Backup File:** \`${fileName}\`\n**Categories:** ${backupData.categories.length}\n**Text Channels:** ${backupData.textChannels.length}\n**Voice Channels:** ${backupData.voiceChannels.length}\n**Messages Backed Up:** ${totalMessages}`)
        .setFooter({ text: 'Use !restore to restore from this backup | Powered By BotLabs' })
        .setTimestamp();

      await statusMsg.edit({ content: '', embeds: [embed] });

      const logEmbed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('üíæ Server Backup Created')
        .setDescription(`**Created by:** ${message.author.tag}\n**Backup:** ${fileName}\n**Messages:** ${totalMessages}`)
        .setTimestamp();

      await logAction(message.guild, logEmbed, 'mod');
    } catch (error) {
      console.error('Backup error:', error);
      await statusMsg.edit('‚ùå Failed to create backup: ' + error.message);
    }
  }

  if (commandName === 'restore') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can restore backups.');
    }

    const backupFile = args[0];
    if (!backupFile) {
      const backupDir = path.join(__dirname, 'backups', message.guild.id);
      try {
        const files = await fs.readdir(backupDir);
        const backupList = files.filter(f => f.endsWith('.json'));
        
        if (backupList.length === 0) {
          return message.reply('‚ùå No backups found for this server.');
        }

        const embed = new EmbedBuilder()
          .setColor('#0099ff')
          .setTitle('üìÇ Available Backups')
          .setDescription(backupList.map((f, i) => `${i + 1}. \`${f}\``).join('\n'))
          .setFooter({ text: 'Use !restore <filename> to restore | Powered By BotLabs' });

        return message.reply({ embeds: [embed] });
      } catch (e) {
        return message.reply('‚ùå No backups found for this server.');
      }
    }

    const statusMsg = await message.reply('‚è≥ Restoring server from backup... This may take a while.');

    try {
      const backupDir = path.join(__dirname, 'backups', message.guild.id);
      const filePath = path.join(backupDir, backupFile);
      const backupData = JSON.parse(await fs.readFile(filePath, 'utf-8'));

      const categoryMap = new Map();
      for (const cat of backupData.categories) {
        const newCategory = await message.guild.channels.create({
          name: cat.name,
          type: ChannelType.GuildCategory,
          position: cat.position
        });
        categoryMap.set(cat.id, newCategory.id);

        for (const perm of cat.permissions) {
          try {
            await newCategory.permissionOverwrites.create(perm.id, {
              allow: BigInt(perm.allow),
              deny: BigInt(perm.deny)
            });
          } catch (e) {}
        }
      }

      let totalMessagesRestored = 0;
      let totalTempWebhooksDeleted = 0;

      for (const txt of backupData.textChannels) {
        const newChannel = await message.guild.channels.create({
          name: txt.name,
          type: ChannelType.GuildText,
          position: txt.position,
          topic: txt.topic,
          nsfw: txt.nsfw,
          parent: categoryMap.get(txt.parentId) || txt.parentId
        });

        for (const perm of txt.permissions) {
          try {
            await newChannel.permissionOverwrites.create(perm.id, {
              allow: BigInt(perm.allow),
              deny: BigInt(perm.deny)
            });
          } catch (e) {}
        }

        if (txt.messages && txt.messages.length > 0) {
          try {
            const webhooksByName = new Map();
            const tempWebhooksToDelete = [];

            for (const msg of txt.messages) {
              try {
                let webhook;
                
                if (msg.isWebhook) {
                  const webhookKey = `${msg.webhookName || 'Unknown'}_${msg.webhookAvatar || 'default'}`;
                  
                  if (webhooksByName.has(webhookKey)) {
                    webhook = webhooksByName.get(webhookKey);
                  } else {
                    webhook = await newChannel.createWebhook({
                      name: msg.webhookName || 'Restored Webhook',
                      avatar: msg.webhookAvatar || null,
                      reason: 'Restoring original webhook from backup'
                    });
                    webhooksByName.set(webhookKey, webhook);
                  }
                } else {
                  const userKey = `user_${msg.author}`;
                  
                  if (webhooksByName.has(userKey)) {
                    webhook = webhooksByName.get(userKey);
                  } else {
                    webhook = await newChannel.createWebhook({
                      name: 'Temp User Restore',
                      reason: 'Temporary webhook for user message restoration'
                    });
                    webhooksByName.set(userKey, webhook);
                    tempWebhooksToDelete.push(webhook);
                  }
                }

                const webhookOptions = {
                  content: msg.content || null,
                  username: msg.author || 'Unknown User',
                  avatarURL: msg.authorAvatar || null,
                  embeds: msg.embeds || []
                };

                if (msg.attachments && msg.attachments.length > 0) {
                  const attachmentText = msg.attachments.map(a => `üìé ${a.name}: ${a.url}`).join('\n');
                  webhookOptions.content = (webhookOptions.content ? webhookOptions.content + '\n\n' : '') + attachmentText;
                }

                await webhook.send(webhookOptions);
                totalMessagesRestored++;
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (msgError) {
                console.log(`Failed to restore message:`, msgError.message);
              }
            }

            for (const webhook of tempWebhooksToDelete) {
              try {
                await webhook.delete('Cleanup: Temporary user webhook after restoration');
                totalTempWebhooksDeleted++;
              } catch (e) {
                console.log('Failed to delete temp webhook:', e.message);
              }
            }
          } catch (webhookError) {
            console.log(`Failed to create webhook for ${txt.name}:`, webhookError.message);
          }
        }
      }

      for (const voice of backupData.voiceChannels) {
        const newChannel = await message.guild.channels.create({
          name: voice.name,
          type: ChannelType.GuildVoice,
          position: voice.position,
          bitrate: voice.bitrate,
          userLimit: voice.userLimit,
          parent: categoryMap.get(voice.parentId) || voice.parentId
        });

        for (const perm of voice.permissions) {
          try {
            await newChannel.permissionOverwrites.create(perm.id, {
              allow: BigInt(perm.allow),
              deny: BigInt(perm.deny)
            });
          } catch (e) {}
        }
      }

      const embed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ Server Restored')
        .setDescription(`Successfully restored from **${backupFile}**\n\n**Restored:**\n‚Ä¢ ${backupData.categories.length} Categories\n‚Ä¢ ${backupData.textChannels.length} Text Channels\n‚Ä¢ ${backupData.voiceChannels.length} Voice Channels\n‚Ä¢ ${totalMessagesRestored} Messages\n\n**Cleanup:**\n‚Ä¢ Deleted ${totalTempWebhooksDeleted} temporary user webhooks\n‚Ä¢ Kept original webhook recreations`)
        .setTimestamp();

      await statusMsg.edit({ content: '', embeds: [embed] });

      const logEmbed = new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚ôªÔ∏è Server Restored from Backup')
        .setDescription(`**Restored by:** ${message.author.tag}\n**Backup:** ${backupFile}\n**Messages Restored:** ${totalMessagesRestored}\n**Temp Webhooks Deleted:** ${totalTempWebhooksDeleted}`)
        .setTimestamp();

      await logAction(message.guild, logEmbed, 'mod');
    } catch (error) {
      console.error('Restore error:', error);
      await statusMsg.edit('‚ùå Failed to restore backup: ' + error.message);
    }
  }

  if (commandName === 'auto_backup') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can configure auto-backup.');
    }

    const action = args[0]?.toLowerCase();
    
    if (action === 'off' || action === 'disable' || action === 'stop') {
      if (client.autoBackupJobs && client.autoBackupJobs.has(message.guild.id)) {
        client.autoBackupJobs.get(message.guild.id).stop();
        client.autoBackupJobs.delete(message.guild.id);
        return message.reply('‚úÖ Auto-backup disabled for this server.');
      } else {
        return message.reply('‚ùå Auto-backup is not currently enabled.');
      }
    }

    const hours = parseInt(args[0]);
    if (!hours || hours < 1 || hours > 24) {
      return message.reply('‚ùå Usage: `!auto_backup <hours>` (e.g., !auto_backup 1 for hourly backups)\n\nValid range: 1-24 hours\nTo disable: `!auto_backup off`');
    }

    if (!client.autoBackupJobs) {
      client.autoBackupJobs = new Map();
    }

    if (client.autoBackupJobs.has(message.guild.id)) {
      client.autoBackupJobs.get(message.guild.id).stop();
    }

    const guildId = message.guild.id;
    const guildName = message.guild.name;
    
    const cronPattern = `0 */${hours} * * *`;
    
    const job = cron.schedule(cronPattern, async () => {
      console.log(`[Auto-Backup] Running backup for ${guildName}`);
      
      try {
        const guild = client.guilds.cache.get(guildId);
        if (!guild) {
          console.log(`[Auto-Backup] Guild ${guildId} not found, stopping job`);
          job.stop();
          return;
        }

        const backupData = {
          guildId: guild.id,
          guildName: guild.name,
          timestamp: Date.now(),
          categories: [],
          textChannels: [],
          voiceChannels: []
        };

        for (const [id, channel] of guild.channels.cache) {
          if (channel.type === ChannelType.GuildCategory) {
            backupData.categories.push({
              id: channel.id,
              name: channel.name,
              position: channel.position,
              permissions: channel.permissionOverwrites.cache.map(p => ({
                id: p.id,
                type: p.type,
                allow: p.allow.bitfield.toString(),
                deny: p.deny.bitfield.toString()
              }))
            });
          } else if (channel.type === ChannelType.GuildText) {
            backupData.textChannels.push({
              id: channel.id,
              name: channel.name,
              position: channel.position,
              topic: channel.topic,
              nsfw: channel.nsfw,
              parentId: channel.parentId,
              permissions: channel.permissionOverwrites.cache.map(p => ({
                id: p.id,
                type: p.type,
                allow: p.allow.bitfield.toString(),
                deny: p.deny.bitfield.toString()
              })),
              messages: []
            });
          } else if (channel.type === ChannelType.GuildVoice) {
            backupData.voiceChannels.push({
              id: channel.id,
              name: channel.name,
              position: channel.position,
              bitrate: channel.bitrate,
              userLimit: channel.userLimit,
              parentId: channel.parentId,
              permissions: channel.permissionOverwrites.cache.map(p => ({
                id: p.id,
                type: p.type,
                allow: p.allow.bitfield.toString(),
                deny: p.deny.bitfield.toString()
              }))
            });
          }
        }

        const backupDir = path.join(__dirname, 'backups', guild.id);
        await fs.mkdir(backupDir, { recursive: true });
        
        const sanitizedName = guild.name.replace(/[^a-z0-9]/gi, '_');
        const fileName = `${sanitizedName}_backup.json`;
        const filePath = path.join(backupDir, fileName);
        
        const oldBackupPath = path.join(backupDir, `${sanitizedName}_backup_old.json`);
        try {
          const stats = await fs.stat(filePath);
          if (stats.isFile()) {
            await fs.rename(filePath, oldBackupPath);
            console.log(`[Auto-Backup] Old backup renamed to ${sanitizedName}_backup_old.json`);
          }
        } catch (error) {
        }
        
        await fs.writeFile(filePath, JSON.stringify(backupData, null, 2));
        
        try {
          await fs.unlink(oldBackupPath);
          console.log(`[Auto-Backup] Deleted old backup file`);
        } catch (error) {
        }

        console.log(`[Auto-Backup] ‚úÖ Backup created: ${fileName}`);
        
        const config = getConfig(guild.id);
        if (config.logChannel) {
          const logChannel = guild.channels.cache.get(config.logChannel);
          if (logChannel && logChannel.isTextBased()) {
            const embed = new EmbedBuilder()
              .setColor('#0099ff')
              .setTitle('üíæ Auto-Backup Completed')
              .setDescription(`Server backup completed successfully.\n\n**Filename:** \`${fileName}\`\n**Categories:** ${backupData.categories.length}\n**Text Channels:** ${backupData.textChannels.length}\n**Voice Channels:** ${backupData.voiceChannels.length}`)
              .setTimestamp();
            await logChannel.send({ embeds: [embed] }).catch(() => {});
          }
        }
      } catch (error) {
        console.error('[Auto-Backup] Failed:', error);
      }
    });

    client.autoBackupJobs.set(guildId, job);

    return message.reply(`‚úÖ Auto-backup enabled! Server will be backed up every **${hours} hour(s)**.\n\n**Backup file:** \`${message.guild.name.replace(/[^a-z0-9]/gi, '_')}_backup.json\`\n**Old backups:** Automatically deleted when new backup is created\n**Disable:** Use \`!auto_backup off\``);
  }


  if (commandName === 'setverify') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.Administrator)) {
      return message.reply('‚ùå You need administrator permissions to use this command.');
    }

    const role = message.mentions.roles.first();
    if (!role) {
      return message.reply('‚ùå Please mention the role to use for verification.\n\nUsage: `!setverify <@role>`');
    }

    client.verificationRoles.set(message.guild.id, role.id);
    await saveVerificationRoles();

    const embed = new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ Verification Role Set')
      .setDescription(`**Role:** ${role}\n**Administrator:** ${message.author.tag}\n\nMembers can now use \`!verify\` to get verified via email.`)
      .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
      .setTimestamp();

    await logAction(message.guild, embed, 'mod');
    return message.reply({ embeds: [embed] });
  }

  if (commandName === 'verify') {
    try {
      await message.delete().catch(() => {});
    } catch (error) {
      console.log('Could not delete verify message');
    }

    const verificationRoleId = client.verificationRoles.get(message.guild.id);
    
    if (!verificationRoleId) {
      return message.author.send('‚ùå Email verification is not set up for this server. Please contact an administrator.').catch(() => {
        message.channel.send(`${message.author}, I couldn't DM you. Please enable DMs from server members.`).then(msg => {
          setTimeout(() => msg.delete().catch(() => {}), 5000);
        });
      });
    }

    const role = message.guild.roles.cache.get(verificationRoleId);
    if (!role) {
      return message.author.send('‚ùå Verification role no longer exists. Please contact an administrator.').catch(() => {});
    }

    if (message.member.roles.cache.has(verificationRoleId)) {
      return message.author.send('‚úÖ You are already verified!').catch(() => {});
    }

    if (!emailTransporter) {
      return message.author.send('‚ùå Email verification is not configured on this bot. Please contact the server administrators.').catch(() => {});
    }

    try {
      // Send initial DM
      const dmEmbed = new EmbedBuilder()
        .setColor('#5865F2')
        .setTitle('üìß Email Verification')
        .setDescription(`Welcome to **${message.guild.name}** verification system!\n\n**Steps:**\n1Ô∏è‚É£ Reply to this DM with your email address\n2Ô∏è‚É£ Check your email for the code\n3Ô∏è‚É£ Reply with the code to complete verification\n\n**Privacy:** Your email is only used for verification and securely stored.\n\n*You have 2 minutes to respond with your email.*`)
        .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
        .setTimestamp();

      await message.author.send({ embeds: [dmEmbed] });

      // Set verification state
      client.verificationCodes.set(message.author.id, {
        guildId: message.guild.id,
        roleId: verificationRoleId,
        waitingForEmail: true,
        waitingForCode: false,
        timestamp: Date.now()
      });

      // Confirmation in channel
      message.channel.send(`${message.author}, check your DMs to start verification! üìß`).then(msg => {
        setTimeout(() => msg.delete().catch(() => {}), 5000);
      });

    } catch (error) {
      console.error('DM send error:', error);
      message.channel.send(`${message.author}, I couldn't DM you. Please enable DMs from server members.`).then(msg => {
        setTimeout(() => msg.delete().catch(() => {}), 8000);
      });
    }
  }

  if (commandName === 'poll') {
    const pollArgs = args.join(' ').split('|').map(s => s.trim());
    if (pollArgs.length < 3) {
      return message.reply('‚ùå Usage: `!poll <question> | <option1> | <option2> | ...`');
    }

    const question = pollArgs[0];
    const options = pollArgs.slice(1);
    
    if (options.length > 10) {
      return message.reply('‚ùå Maximum 10 options allowed.');
    }

    const emojis = ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü'];
    const optionsText = options.map((opt, i) => `${emojis[i]} ${opt}`).join('\n');

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üìä ${question}`)
      .setDescription(optionsText)
      .setFooter({ text: `Poll by ${message.author.tag} | Powered By BotLabs` })
      .setTimestamp();

    const pollMsg = await message.channel.send({ embeds: [embed] });
    for (let i = 0; i < options.length; i++) {
      await pollMsg.react(emojis[i]);
    }
  }

  if (commandName === 'serverinfo') {
    const guild = message.guild;
    const owner = await guild.fetchOwner();

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üìä Server Information - ${guild.name}`)
      .setThumbnail(guild.iconURL({ dynamic: true }))
      .addFields(
        { name: 'üÜî Server ID', value: guild.id, inline: true },
        { name: 'üëë Owner', value: owner.user.tag, inline: true },
        { name: 'üìÖ Created', value: `<t:${Math.floor(guild.createdTimestamp / 1000)}:R>`, inline: true },
        { name: 'üë• Members', value: guild.memberCount.toString(), inline: true },
        { name: 'üí¨ Channels', value: guild.channels.cache.size.toString(), inline: true },
        { name: 'üé≠ Roles', value: guild.roles.cache.size.toString(), inline: true },
        { name: 'üòä Emojis', value: guild.emojis.cache.size.toString(), inline: true },
        { name: 'üîí Verification', value: guild.verificationLevel.toString(), inline: true },
        { name: 'üõ°Ô∏è Boost Level', value: `Level ${guild.premiumTier}`, inline: true }
      )
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'userinfo') {
    const user = message.mentions.users.first() || message.author;
    const member = message.guild.members.cache.get(user.id);

    const embed = new EmbedBuilder()
      .setColor('#0099ff')
      .setTitle(`üë§ User Information - ${user.tag}`)
      .setThumbnail(user.displayAvatarURL({ dynamic: true }))
      .addFields(
        { name: 'üÜî User ID', value: user.id, inline: true },
        { name: 'üìÖ Account Created', value: `<t:${Math.floor(user.createdTimestamp / 1000)}:R>`, inline: true },
        { name: 'üì• Joined Server', value: member ? `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>` : 'N/A', inline: true },
        { name: 'üé≠ Roles', value: member ? member.roles.cache.filter(r => r.id !== message.guild.id).map(r => r.name).join(', ') || 'None' : 'N/A', inline: false },
        { name: 'ü§ñ Bot', value: user.bot ? 'Yes' : 'No', inline: true }
      )
      .setTimestamp();

    message.reply({ embeds: [embed] });
  }

  if (commandName === 'nick') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageNicknames)) {
      return message.reply('‚ùå You need manage nicknames permissions.');
    }

    const member = message.mentions.members.first();
    if (!member) {
      return message.reply('‚ùå Please mention a user.');
    }

    const nickname = args.slice(1).join(' ');
    if (!nickname) {
      return message.reply('‚ùå Please provide a nickname.');
    }

    await member.setNickname(nickname);
    message.reply(`‚úÖ Set nickname for **${member.user.tag}** to **${nickname}**`);
  }

  if (commandName === 'addrole') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageRoles)) {
      return message.reply('‚ùå You need manage roles permissions.');
    }

    const member = message.mentions.members.first();
    const role = message.mentions.roles.first();

    if (!member || !role) {
      return message.reply('‚ùå Usage: `!addrole <@user> <@role>`');
    }

    await member.roles.add(role);
    message.reply(`‚úÖ Added **${role.name}** role to **${member.user.tag}**`);
  }

  if (commandName === 'removerole') {
    if (!checkPermissions(message.member, config, PermissionFlagsBits.ManageRoles)) {
      return message.reply('‚ùå You need manage roles permissions.');
    }

    const member = message.mentions.members.first();
    const role = message.mentions.roles.first();

    if (!member || !role) {
      return message.reply('‚ùå Usage: `!removerole <@user> <@role>`');
    }

    await member.roles.remove(role);
    message.reply(`‚úÖ Removed **${role.name}** role from **${member.user.tag}**`);
  }

  if (commandName === 'deletechannels') {
    if (!isBotOwnerOrServerOwner(message.author.id, message.guild)) {
      return message.reply('‚ùå Only the server owner or bot owner can delete all channels.');
    }

    const confirm = args[0]?.toLowerCase();
    if (confirm !== 'confirm') {
      const embed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('‚ö†Ô∏è Delete All Channels')
        .setDescription('**WARNING:** This will delete ALL channels in the server!\n\nThis action cannot be undone. To confirm, use:\n`!deletechannels confirm`')
        .setFooter({ text: 'Make sure to create a backup first with !backup | Powered By BotLabs' })
        .setTimestamp();

      return message.reply({ embeds: [embed] });
    }

    const statusMsg = await message.reply('‚è≥ Deleting all channels... Please wait.');

    try {
      let deleted = 0;
      let failed = 0;
      const currentChannelId = message.channel.id;

      for (const [id, channel] of message.guild.channels.cache) {
        if (channel.id === currentChannelId) continue;
        
        try {
          await channel.delete(`Mass channel deletion by ${isOwner(message.author.id) ? 'bot owner' : 'server owner'}`);
          deleted++;
        } catch (e) {
          failed++;
          console.error(`Failed to delete channel ${channel.name}:`, e.message);
        }
      }

      const embed = new EmbedBuilder()
        .setColor('#FF6600')
        .setTitle('üóëÔ∏è Channels Deleted')
        .setDescription(`**Deleted:** ${deleted} channels\n**Failed:** ${failed} channels\n\nThis channel will remain for confirmation.`)
        .setFooter({ text: 'You can now restore from a backup using !restore | Powered By BotLabs' })
        .setTimestamp();

      try {
        await statusMsg.edit({ content: '', embeds: [embed] });
      } catch (editError) {
        console.error('Failed to edit status message:', editError.message);
        try {
          await message.channel.send({ embeds: [embed] });
        } catch (sendError) {
          console.error('Failed to send completion message:', sendError.message);
        }
      }

      const logEmbed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('üóëÔ∏è Mass Channel Deletion')
        .setDescription(`**Executed by:** ${message.author.tag}\n**Deleted:** ${deleted}\n**Failed:** ${failed}`)
        .setTimestamp();

      await logAction(message.guild, logEmbed, 'mod');
    } catch (error) {
      console.error('Delete channels error:', error);
      try {
        await statusMsg.edit('‚ùå Failed to delete channels: ' + error.message).catch(() => {});
      } catch (e) {
        console.error('Could not send error message:', e.message);
      }
    }
  }
});

client.on('guildMemberAdd', async (member) => {
  const config = getConfig(member.guild.id);

  if (member.user.bot && config.botDetectionEnabled) {
    if (config.whitelistedBots.has(member.id)) return;

    const dangerousPermissions = [
      PermissionFlagsBits.Administrator,
      PermissionFlagsBits.ManageGuild,
      PermissionFlagsBits.ManageRoles,
      PermissionFlagsBits.ManageChannels,
      PermissionFlagsBits.BanMembers,
      PermissionFlagsBits.KickMembers,
      PermissionFlagsBits.ManageWebhooks
    ];

    const auditLogs = await member.guild.fetchAuditLogs({
      type: 28,
      limit: 1
    }).catch(() => null);

    if (auditLogs) {
      const botAddLog = auditLogs.entries.first();
      if (botAddLog && botAddLog.target.id === member.id) {
        const inviter = botAddLog.executor;
        const inviterMember = member.guild.members.cache.get(inviter.id);
        const userWhitelist = client.userWhitelists.get(member.guild.id) || new Set();
        const isUserWhitelisted = userWhitelist.has(inviter.id);
        const isBotVerified = member.user.flags?.has('VerifiedBot') || false;
        
        let hasDangerousPerms = false;
        for (const perm of dangerousPermissions) {
          if (member.permissions.has(perm)) {
            hasDangerousPerms = true;
            break;
          }
        }

        if (isUserWhitelisted) {
          return;
        }
        
        if (!isBotVerified) {
          await member.ban({ reason: 'üö® SECURITY: Unverified bot added by non-whitelisted admin' }).catch(() => {});
          
          let inviterAction = '';
          if (inviterMember && !isProtectedUser(inviterMember.id, member.guild)) {
            await quarantineUser(member.guild, inviterMember, `üö® Security: Added unverified bot (${member.user.tag}) - Only Discord-verified bots allowed`);
            inviterAction = 'üîí Admin quarantined - Non-whitelisted admins can only add Discord-verified bots';
          } else if (inviterMember && isProtectedUser(inviterMember.id, member.guild)) {
            inviterAction = '‚ö†Ô∏è Protected user (bot owner or server owner) - Not quarantined';
          } else {
            inviterAction = '‚ùå Could not quarantine admin (not found)';
          }

          const alertDescription = `**‚ö†Ô∏è UNVERIFIED BOT BLOCKED**\n\n` +
            `**Bot:** ${member.user.tag} (${member.id})\n` +
            `**Invited By:** ${inviter.tag} (${inviter.id})\n` +
            `**Bot Status:** Not Discord-verified\n\n` +
            `**Actions Taken:**\n` +
            `‚úÖ Bot permanently banned\n` +
            `${inviterAction}\n\n` +
            `**Policy:** Non-whitelisted admins can only add Discord-verified bots.\n` +
            `**To whitelist an admin:** Server owner can use \`!userwhitelist add @user\`\n\n` +
            `**This channel will auto-delete in 24 hours or can be manually deleted.**`;

          const alertChannel = await createAdminAlertChannel(
            member.guild,
            '‚ö†Ô∏è UNVERIFIED BOT BLOCKED',
            alertDescription
          );

          const logEmbed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚ö†Ô∏è Unverified Bot Blocked')
            .setDescription(`**Bot:** ${member.user.tag}\n**Inviter:** ${inviter.tag}\n**Admin quarantined for adding unverified bot**`)
            .setTimestamp();

          await logAction(member.guild, logEmbed);

          if (alertChannel) {
            setTimeout(async () => {
              await alertChannel.delete().catch(() => {});
            }, 24 * 60 * 60 * 1000);
          }
          
          return;
        }

        if (hasDangerousPerms && !config.whitelistedUsers.has(inviter.id)) {
          await member.ban({ reason: 'üö® SECURITY: Suspicious bot with dangerous permissions detected' }).catch(() => {});
          
          let inviterAction = '';
          
          if (inviterMember && !isProtectedUser(inviterMember.id, member.guild)) {
            await quarantineUser(member.guild, inviterMember, `üö® Anti-Nuke: Bot (${member.user.tag}) triggered nuke detection with dangerous permissions`);
            inviterAction = 'üîí Admin quarantined - Bot triggered anti-nuke protection';
          } else if (inviterMember && isProtectedUser(inviterMember.id, member.guild)) {
            inviterAction = '‚ö†Ô∏è Protected user (bot owner or server owner) - Cannot quarantine';
          } else {
            inviterAction = '‚ùå Could not quarantine inviter (not found)';
          }

          const alertDescription = `**üö® NUKE BOT DETECTED AND NEUTRALIZED**\n\n` +
            `**Suspicious Bot:** ${member.user.tag} (${member.id})\n` +
            `**Invited By:** ${inviter.tag} (${inviter.id})\n` +
            `**Bot Verified:** ${isBotVerified ? 'Yes' : 'No'}\n` +
            `**Admin Whitelisted:** ${isUserWhitelisted ? 'Yes (still quarantined)' : 'No'}\n\n` +
            `**Dangerous Permissions Detected:**\n` +
            dangerousPermissions.filter(perm => member.permissions.has(perm))
              .map(perm => `‚Ä¢ ${Object.keys(PermissionFlagsBits).find(key => PermissionFlagsBits[key] === perm)}`)
              .join('\n') +
            `\n\n**Actions Taken:**\n` +
            `‚úÖ Bot permanently banned\n` +
            `${inviterAction}\n\n` +
            `**Note:** Even whitelisted users get quarantined if their bot triggers anti-nuke.\n` +
            `**To bypass anti-nuke:** Server owner can use \`!botwhitelist add <bot_id>\`\n\n` +
            `**This channel will auto-delete in 24 hours or can be manually deleted.**`;

          const alertChannel = await createAdminAlertChannel(
            member.guild,
            'üö® NUKE BOT DETECTED & NEUTRALIZED',
            alertDescription
          );

          const logEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('üö® Nuke Bot Detection System Activated')
            .setDescription(`**Bot:** ${member.user.tag}\n**Inviter:** ${inviter.tag}\n**Bot banned, Admin quarantined**`)
            .setTimestamp();

          await logAction(member.guild, logEmbed);

          console.log(`üö® Nuke bot detected and banned: ${member.user.tag} (invited by ${inviter.tag}, quarantined)`);

          if (alertChannel) {
            setTimeout(async () => {
              await alertChannel.delete().catch(() => {});
            }, 24 * 60 * 60 * 1000);
          }
          
          return;
        }
      }
    }
  }

  const joinEmbed = new EmbedBuilder()
    .setColor('#00FF00')
    .setTitle('üì• Member Joined')
    .setThumbnail(member.user.displayAvatarURL({ dynamic: true }))
    .addFields(
      { name: 'User', value: `${member.user.tag} (${member.id})`, inline: false },
      { name: 'Account Created', value: `<t:${Math.floor(member.user.createdTimestamp / 1000)}:R>`, inline: true },
      { name: 'Member Count', value: `${member.guild.memberCount}`, inline: true }
    )
    .setTimestamp();

  await logAction(member.guild, joinEmbed, 'join');

  if (!config.antiRaidEnabled) return;

  const guildId = member.guild.id;
  const now = Date.now();
  
  if (!raidDetection.has(guildId)) {
    raidDetection.set(guildId, []);
  }
  
  const joins = raidDetection.get(guildId).filter(time => now - time < config.raidTimeWindow);
  joins.push(now);
  raidDetection.set(guildId, joins);

  const accountAge = now - member.user.createdTimestamp;
  const accountAgeDays = Math.floor(accountAge / (1000 * 60 * 60 * 24));

  if (accountAgeDays < config.accountAgeThreshold && joins.length >= config.raidThreshold) {
    if (member.kickable) {
      await member.kick('Anti-Raid: Suspicious new account during raid').catch(() => {});
      
      const kickEmbed = new EmbedBuilder()
        .setColor('#FFA500')
        .setTitle('üõ°Ô∏è Anti-Raid: Suspicious Account Kicked')
        .setDescription(`**User:** ${member.user.tag} (${member.id})\n**Account Age:** ${accountAgeDays} days\n**Reason:** New account joining during raid detection`)
        .setTimestamp();
      
      await logAction(member.guild, kickEmbed);
    }
  }

  if (joins.length >= config.raidThreshold) {
    const embed = new EmbedBuilder()
      .setColor('#FFA500')
      .setTitle('üö® Raid Detected')
      .setDescription(`**${joins.length}** members joined within **${config.raidTimeWindow / 1000}** seconds\n\nConsider enabling lockdown or verifying new members.`)
      .setTimestamp();
    
    await logAction(member.guild, embed);
  }

  const autoroleSettings = client.autoroleSettings.get(member.guild.id);
  if (autoroleSettings && autoroleSettings.roleId && !member.user.bot) {
    const assignAutorole = async () => {
      try {
        const freshMember = await member.guild.members.fetch(member.id);
        
        if (autoroleSettings.requireNotTimedOut && freshMember.communicationDisabledUntilTimestamp && freshMember.communicationDisabledUntilTimestamp > Date.now()) {
          console.log(`Autorole not assigned to ${member.user.tag}: Member is timed out`);
          return;
        }

        if (autoroleSettings.requireVerified) {
          const verificationRoleId = client.verificationRoles.get(member.guild.id);
          if (verificationRoleId && !freshMember.roles.cache.has(verificationRoleId)) {
            console.log(`Autorole not assigned to ${member.user.tag}: Not verified`);
            return;
          }
        }

        const role = member.guild.roles.cache.get(autoroleSettings.roleId);
        if (role && !freshMember.roles.cache.has(autoroleSettings.roleId)) {
          await freshMember.roles.add(autoroleSettings.roleId);
          console.log(`‚úÖ Autorole assigned: ${role.name} to ${member.user.tag}`);
        }
      } catch (error) {
        console.error('Failed to assign autorole:', error);
      }
    };

    if (autoroleSettings.joinDelayMinutes > 0) {
      setTimeout(assignAutorole, autoroleSettings.joinDelayMinutes * 60 * 1000);
    } else {
      await assignAutorole();
    }
  }
});

client.on('guildMemberRemove', async (member) => {
  const leaveEmbed = new EmbedBuilder()
    .setColor('#FF0000')
    .setTitle('üì§ Member Left')
    .setThumbnail(member.user.displayAvatarURL({ dynamic: true }))
    .addFields(
      { name: 'User', value: `${member.user.tag} (${member.id})`, inline: false },
      { name: 'Joined', value: `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>`, inline: true },
      { name: 'Member Count', value: `${member.guild.memberCount}`, inline: true }
    )
    .setTimestamp();

  await logAction(member.guild, leaveEmbed, 'join');
});

client.on('messageReactionAdd', async (reaction, user) => {
  if (user.bot) return;

  if (reaction.partial) {
    try {
      await reaction.fetch();
    } catch (error) {
      console.error('Failed to fetch reaction:', error);
      return;
    }
  }

  const reactionRoleData = client.reactionRoles.get(reaction.message.id);
  if (!reactionRoleData) return;

  const emoji = reaction.emoji.name || reaction.emoji.id;
  const roleId = reactionRoleData.roles.get(emoji);
  if (!roleId) return;

  try {
    const guild = reaction.message.guild;
    const member = await guild.members.fetch(user.id);
    const role = guild.roles.cache.get(roleId);

    if (role && !member.roles.cache.has(roleId)) {
      await member.roles.add(roleId);
      console.log(`‚úÖ Reaction role assigned: ${role.name} to ${user.tag}`);
    }
  } catch (error) {
    console.error('Failed to assign reaction role:', error);
  }
});

client.on('messageReactionRemove', async (reaction, user) => {
  if (user.bot) return;

  if (reaction.partial) {
    try {
      await reaction.fetch();
    } catch (error) {
      console.error('Failed to fetch reaction:', error);
      return;
    }
  }

  const reactionRoleData = client.reactionRoles.get(reaction.message.id);
  if (!reactionRoleData) return;

  const emoji = reaction.emoji.name || reaction.emoji.id;
  const roleId = reactionRoleData.roles.get(emoji);
  if (!roleId) return;

  try {
    const guild = reaction.message.guild;
    const member = await guild.members.fetch(user.id);
    const role = guild.roles.cache.get(roleId);

    if (role && member.roles.cache.has(roleId)) {
      await member.roles.remove(roleId);
      console.log(`‚úÖ Reaction role removed: ${role.name} from ${user.tag}`);
    }
  } catch (error) {
    console.error('Failed to remove reaction role:', error);
  }
});

client.on('guildAuditLogEntryCreate', async (auditLog) => {
  if (!auditLog || !auditLog.guild) return;
  
  const config = getConfig(auditLog.guild.id);
  if (!config.antiNukeEnabled) return;
  
  const { action, executor, target, createdTimestamp } = auditLog;
  
  if (!executor || executor.bot) return;
  if (isProtectedUser(executor.id, auditLog.guild)) return;
  
  const userWhitelist = client.userWhitelists.get(auditLog.guild.id) || new Set();
  if (userWhitelist.has(executor.id)) return;
  
  const guildId = auditLog.guild.id;
  const userId = executor.id;
  const cacheKey = `${guildId}-${userId}`;
  const now = Date.now();
  const timeWindow = 10000;
  
  if (!antiNukeCache.has(cacheKey)) {
    antiNukeCache.set(cacheKey, {
      channelDeletes: [],
      roleDeletes: [],
      bans: [],
      kicks: [],
      webhooks: []
    });
  }
  
  const userActions = antiNukeCache.get(cacheKey);
  
  const cleanActions = (actionArray) => {
    return actionArray.filter(timestamp => now - timestamp < timeWindow);
  };
  
  userActions.channelDeletes = cleanActions(userActions.channelDeletes);
  userActions.roleDeletes = cleanActions(userActions.roleDeletes);
  userActions.bans = cleanActions(userActions.bans);
  userActions.kicks = cleanActions(userActions.kicks);
  userActions.webhooks = cleanActions(userActions.webhooks);
  
  let shouldQuarantine = false;
  let reason = '';
  
  if (action === AuditLogEvent.ChannelDelete) {
    userActions.channelDeletes.push(now);
    if (userActions.channelDeletes.length >= 3) {
      shouldQuarantine = true;
      reason = `üö® Anti-Nuke: Deleted ${userActions.channelDeletes.length} channels in ${timeWindow / 1000}s`;
    }
  }
  
  else if (action === AuditLogEvent.RoleDelete) {
    userActions.roleDeletes.push(now);
    if (userActions.roleDeletes.length >= 3) {
      shouldQuarantine = true;
      reason = `üö® Anti-Nuke: Deleted ${userActions.roleDeletes.length} roles in ${timeWindow / 1000}s`;
    }
  }
  
  else if (action === AuditLogEvent.MemberBanAdd) {
    userActions.bans.push(now);
    if (userActions.bans.length >= 5) {
      shouldQuarantine = true;
      reason = `üö® Anti-Nuke: Banned ${userActions.bans.length} members in ${timeWindow / 1000}s`;
    }
  }
  
  else if (action === AuditLogEvent.MemberKick) {
    userActions.kicks.push(now);
    if (userActions.kicks.length >= 5) {
      shouldQuarantine = true;
      reason = `üö® Anti-Nuke: Kicked ${userActions.kicks.length} members in ${timeWindow / 1000}s`;
    }
  }
  
  else if (action === AuditLogEvent.WebhookCreate) {
    userActions.webhooks.push(now);
    if (userActions.webhooks.length >= 3) {
      shouldQuarantine = true;
      reason = `üö® Anti-Nuke: Created ${userActions.webhooks.length} webhooks in ${timeWindow / 1000}s`;
    }
  }
  
  if (shouldQuarantine) {
    const member = await auditLog.guild.members.fetch(userId).catch(() => null);
    if (member && !isProtectedUser(member.id, auditLog.guild)) {
      await quarantineUser(auditLog.guild, member, reason);
      
      const actionType = action === AuditLogEvent.ChannelDelete ? 'Channel Deletions' :
                         action === AuditLogEvent.RoleDelete ? 'Role Deletions' :
                         action === AuditLogEvent.MemberBanAdd ? 'Member Bans' :
                         action === AuditLogEvent.MemberKick ? 'Member Kicks' :
                         action === AuditLogEvent.WebhookCreate ? 'Webhook Creations' : 'Unknown';
      
      const alertDescription = `**üö® NUKE ATTEMPT DETECTED & BLOCKED**\n\n` +
        `**Attacker:** ${executor.tag} (${executor.id})\n` +
        `**Detected Action:** ${actionType}\n` +
        `**Actions in ${timeWindow / 1000}s:** ${action === AuditLogEvent.ChannelDelete ? userActions.channelDeletes.length :
                                                   action === AuditLogEvent.RoleDelete ? userActions.roleDeletes.length :
                                                   action === AuditLogEvent.MemberBanAdd ? userActions.bans.length :
                                                   action === AuditLogEvent.MemberKick ? userActions.kicks.length :
                                                   userActions.webhooks.length}\n\n` +
        `**Actions Taken:**\n` +
        `‚úÖ User quarantined (all permissions removed)\n` +
        `‚úÖ Admin alert channel created\n\n` +
        `**To remove quarantine:** Server admins can use \`!unquarantine @user\`\n` +
        `**To whitelist trusted admins:** Owner can use \`!userwhitelist add @user\`\n\n` +
        `**This channel will auto-delete in 24 hours or can be manually deleted.**`;
      
      const alertChannel = await createAdminAlertChannel(
        auditLog.guild,
        'üö® NUKE ATTEMPT BLOCKED',
        alertDescription
      );
      
      const logEmbed = new EmbedBuilder()
        .setColor('#FF0000')
        .setTitle('üö® Anti-Nuke System Activated')
        .setDescription(`**User:** ${executor.tag}\n**Action:** ${actionType}\n**User quarantined**`)
        .setTimestamp();
      
      await logAction(auditLog.guild, logEmbed);
      
      if (alertChannel) {
        setTimeout(async () => {
          await alertChannel.delete().catch(() => {});
        }, 24 * 60 * 60 * 1000);
      }
      
      antiNukeCache.delete(cacheKey);
    }
  }
});

client.on('interactionCreate', async (interaction) => {
  try {
    if (interaction.isButton()) {
      if (interaction.customId.startsWith('verify_start_')) {
        const userId = interaction.customId.split('_')[2];
        
        if (interaction.user.id !== userId) {
          return interaction.reply({ content: '‚ùå This button is not for you! Use `!verify` to start your own verification.', ephemeral: true });
        }

        const verificationRoleId = client.verificationRoles.get(interaction.guild.id);
        if (!verificationRoleId) {
          return interaction.reply({ content: '‚ùå Email verification is not set up for this server.', ephemeral: true });
        }

        const member = interaction.guild.members.cache.get(interaction.user.id);
        if (member.roles.cache.has(verificationRoleId)) {
          return interaction.reply({ content: '‚úÖ You are already verified!', ephemeral: true });
        }

        if (!emailTransporter) {
          return interaction.reply({ content: '‚ùå Email verification is not configured on this bot.', ephemeral: true });
        }

        const modal = new ModalBuilder()
          .setCustomId(`verify_email_${interaction.user.id}`)
          .setTitle('üìß Email Verification');

        const emailInput = new TextInputBuilder()
          .setCustomId('email_input')
          .setLabel('Enter your email address')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('user@example.com')
          .setRequired(true)
          .setMaxLength(100);

        const row = new ActionRowBuilder().addComponents(emailInput);
        modal.addComponents(row);

        await interaction.showModal(modal);
      }
    }

    if (interaction.isModalSubmit()) {
      if (interaction.customId.startsWith('verify_email_')) {
        const userId = interaction.customId.split('_')[2];
        
        if (interaction.user.id !== userId) {
          return interaction.reply({ content: '‚ùå This is not your verification!', ephemeral: true });
        }

        const email = interaction.fields.getTextInputValue('email_input').trim();
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

        if (!emailRegex.test(email)) {
          return interaction.reply({ content: '‚ùå Invalid email format. Please try again with a valid email address.', ephemeral: true });
        }

        await interaction.deferReply({ ephemeral: true });

        const code = Math.floor(100000 + Math.random() * 900000).toString();

        try {
          await emailTransporter.sendMail({
            from: process.env.EMAIL_USER,
            to: email,
            subject: 'Discord Server Verification Code',
            html: `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h2 style="color: #5865F2;">Discord Server Verification</h2>
                <p>Your verification code is:</p>
                <div style="background-color: #f0f0f0; padding: 20px; text-align: center; border-radius: 10px;">
                  <h1 style="color: #5865F2; font-size: 48px; letter-spacing: 10px; margin: 0;">${code}</h1>
                </div>
                <p style="margin-top: 20px;">Enter this code in Discord to complete verification.</p>
                <p style="color: #ff0000;"><strong>This code will expire in 10 minutes.</strong></p>
                <p style="color: #666; font-size: 12px;">If you didn't request this, please ignore this email.</p>
              </div>
            `
          });

          client.verificationCodes.set(interaction.user.id, {
            guildId: interaction.guild.id,
            email: email,
            code: code,
            codeExpiry: Date.now() + 600000,
            timestamp: Date.now()
          });

          const embed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ Verification Code Sent!')
            .setDescription(`A 6-digit verification code has been sent to **${email}**\n\n‚è∞ Code expires in **10 minutes**\n\nClick the button below to enter your code.`)
            .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
            .setTimestamp();

          const button = new ButtonBuilder()
            .setCustomId(`verify_code_${interaction.user.id}`)
            .setLabel('üîë Enter Verification Code')
            .setStyle(ButtonStyle.Success);

          const row = new ActionRowBuilder().addComponents(button);

          await interaction.editReply({ embeds: [embed], components: [row] });
        } catch (error) {
          console.error('Email send error:', error);
          await interaction.editReply({ content: '‚ùå Failed to send verification email. Please make sure the email address is correct and try again.' });
        }
      } else if (interaction.customId.startsWith('verify_code_')) {
        const userId = interaction.customId.split('_')[2];
        
        if (interaction.user.id !== userId) {
          return interaction.reply({ content: '‚ùå This is not your verification!', ephemeral: true });
        }

        const providedCode = interaction.fields.getTextInputValue('code_input').trim();
        const verificationData = client.verificationCodes.get(interaction.user.id);

        if (!verificationData) {
          return interaction.reply({ content: '‚ùå No verification in progress. Please start over with `!verify`.', ephemeral: true });
        }

        if (Date.now() > verificationData.codeExpiry) {
          client.verificationCodes.delete(interaction.user.id);
          return interaction.reply({ content: '‚ùå Verification code expired. Please start over with `!verify`.', ephemeral: true });
        }

        if (providedCode !== verificationData.code) {
          return interaction.reply({ content: '‚ùå Incorrect verification code. Please check your email and try again.', ephemeral: true });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
          const guild = interaction.guild;
          const member = guild.members.cache.get(interaction.user.id);
          
          const verificationRoleId = client.verificationRoles.get(guild.id);
          if (!verificationRoleId) {
            client.verificationCodes.delete(interaction.user.id);
            return interaction.editReply({ content: '‚ùå Verification role no longer exists. Please contact server administrators.' });
          }

          const role = guild.roles.cache.get(verificationRoleId);
          if (!role) {
            client.verificationCodes.delete(interaction.user.id);
            return interaction.editReply({ content: '‚ùå Verification role not found. Please contact server administrators.' });
          }

          await member.roles.add(role);

          const successEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ Verification Successful!')
            .setDescription(`You have been verified in **${guild.name}**!\n\n**Role Assigned:** ${role}\n\nYou can now access the server!`)
            .setFooter({ text: 'Shield Security System v1.4.5 | Powered By BotLabs' })
            .setTimestamp();

          await interaction.editReply({ embeds: [successEmbed] });

          const config = getConfig(guild.id);
          const logEmbed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('‚úÖ Member Verified')
            .setDescription(`**User:** ${interaction.user.tag} (${interaction.user.id})\n**Email:** ${verificationData.email}\n**Role:** ${role}`)
            .setTimestamp();

          await logAction(guild, logEmbed, 'mod');

          client.verificationCodes.delete(interaction.user.id);
        } catch (error) {
          console.error('Verification error:', error);
          await interaction.editReply({ content: '‚ùå An error occurred during verification. Please try again or contact server administrators.' });
        }
      }
    }

    if (interaction.isButton() && interaction.customId.startsWith('verify_code_')) {
      const userId = interaction.customId.split('_')[2];
      
      if (interaction.user.id !== userId) {
        return interaction.reply({ content: '‚ùå This button is not for you!', ephemeral: true });
      }

      const verificationData = client.verificationCodes.get(interaction.user.id);
      if (!verificationData) {
        return interaction.reply({ content: '‚ùå No verification in progress. Please start over with `!verify`.', ephemeral: true });
      }

      if (Date.now() > verificationData.codeExpiry) {
        client.verificationCodes.delete(interaction.user.id);
        return interaction.reply({ content: '‚ùå Verification code expired. Please start over with `!verify`.', ephemeral: true });
      }

      const modal = new ModalBuilder()
        .setCustomId(`verify_code_${interaction.user.id}`)
        .setTitle('üîë Enter Verification Code');

      const codeInput = new TextInputBuilder()
        .setCustomId('code_input')
        .setLabel('Enter the 6-digit code from your email')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('123456')
        .setRequired(true)
        .setMinLength(6)
        .setMaxLength(6);

      const row = new ActionRowBuilder().addComponents(codeInput);
      modal.addComponents(row);

      await interaction.showModal(modal);
    }
  } catch (error) {
    console.error('Interaction error:', error);
    if (!interaction.replied && !interaction.deferred) {
      await interaction.reply({ content: '‚ùå An error occurred. Please try again.', ephemeral: true }).catch(() => {});
    }
  }
});

async function startBot() {
  await loadData();
  console.log('‚úÖ All data loaded successfully');
  
  const token = process.env.DISCORD_TOKEN;
  console.log('=== TOKEN DEBUG ===');
  console.log('Token exists:', !!token);
  console.log('Token type:', typeof token);
  console.log('Token length:', token?.length);
  console.log('Token first 10 chars:', token?.substring(0, 10));
  console.log('Token last 10 chars:', token?.substring(token?.length - 10));
  console.log('Has whitespace at start:', token?.[0] === ' ' || token?.[0] === '\n');
  console.log('Has whitespace at end:', token?.[token?.length - 1] === ' ' || token?.[token?.length - 1] === '\n');
  console.log('==================');
  
  await client.login(token?.trim());
}

startBot().catch(console.error);